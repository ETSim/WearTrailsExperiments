<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Variant Blend with Grayscale Map</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0e12; color: #eaeef5; font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #app { position: fixed; inset: 0; display: grid; grid-template-columns: 1fr 360px; }
    #viewport { position: relative; }
    #ui { border-left: 1px solid #1b2230; padding: 12px; overflow: auto; }
    .h { font-weight: 700; letter-spacing: .02em; font-size: 13px; text-transform: uppercase; color: #9fb3c8; margin: 10px 0 6px; }
    .row { margin: 8px 0 12px; }
    .btn { display: inline-flex; align-items: center; gap: .5rem; background: #141a23; border: 1px solid #263247; color: #eaeef5; padding: 10px 12px; border-radius: 12px; cursor: pointer; }
    .btn:hover { background: #1a2230; }
    input[type="file"] { display: none; }
    .kv { display:flex; justify-content: space-between; font-size: 12px; color:#9fb3c8; }
    label { font-size: 12px; color:#9fb3c8; display:block; margin-bottom: 4px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
<div id="app">
  <div id="viewport"></div>
  <aside id="ui">
    <div class="h">Load Model</div>
    <div class="row">
      <label class="btn" for="fileGLB">ðŸ“¦ Upload GLB/GLTF</label>
      <input id="fileGLB" type="file" accept=".glb,.gltf,model/gltf-binary,model/gltf+json" />
    </div>

    <div class="h">Blend Map (Grayscale)</div>
    <div class="row">
      <label class="btn" for="fileBlend">ðŸŽ¨ Upload Blend Map</label>
      <input id="fileBlend" type="file" accept=".png,.jpg,.jpeg,.webp" />
      <div class="kv" style="margin-top:8px;">
        <span>Status</span><span id="blendStatus">embedded</span>
      </div>
    </div>

    <div class="h">Flow Map (Direction)</div>
    <div class="row">
      <label class="btn" for="fileFlow">ðŸŒŠ Upload Flow Map</label>
      <input id="fileFlow" type="file" accept=".png,.jpg,.jpeg,.webp" />
      <div class="kv" style="margin-top:8px;">
        <span>Status</span><span id="flowStatus">none</span>
      </div>
    </div>
    <div class="row grid">
      <div>
        <label>Rotation Strength</label>
        <input id="rotStrength" type="range" min="0" max="360" step="1" value="180" />
        <div class="kv"><span></span><span id="rotStrengthVal">180Â°</span></div>
      </div>
      <div>
        <label>Flow Threshold</label>
        <input id="flowThreshold" type="range" min="0" max="1" step="0.01" value="0.1" />
        <div class="kv"><span></span><span id="flowThresholdVal">0.10</span></div>
      </div>
    </div>
    <div class="row grid">
      <div>
        <label>Enable Flow</label>
        <select id="enableFlow">
          <option value="0" selected>Off</option>
          <option value="1">On</option>
        </select>
      </div>
    </div>

    <div class="h">Blend Controls</div>
    <div class="row grid">
      <div>
        <label>Smoothstep</label>
        <input id="smooth" type="range" min="0" max="1" step="0.01" value="0.5" />
        <div class="kv"><span></span><span id="smoothVal">0.50</span></div>
      </div>
      <div>
        <label>Contrast</label>
        <input id="contrast" type="range" min="0.1" max="3" step="0.01" value="1" />
        <div class="kv"><span></span><span id="contrastVal">1.00</span></div>
      </div>
    </div>
    <div class="row grid">
      <div>
        <label>Invert</label>
        <select id="invert">
          <option value="0" selected>No</option>
          <option value="1">Yes</option>
        </select>
      </div>
    </div>

    <div class="h">Camera & Lighting</div>
    <div class="row grid">
      <div>
        <label>Exposure</label>
        <input id="exposure" type="range" min="0.25" max="3.0" step="0.01" value="1.8" />
        <div class="kv"><span></span><span id="exposureVal">1.80</span></div>
      </div>
      <div style="display:flex; align-items:flex-end;">
        <button id="frameBtn" class="btn" style="width:100%;">ðŸŽ¯ Frame Camera</button>
      </div>
    </div>

    <div class="h">Info</div>
    <div class="row">
      <div class="kv"><span>Variants detected:</span><span id="nDetected">â€”</span></div>
      <div class="kv"><span>Sampler cap:</span><span id="nCap">â€”</span></div>
      <div class="kv"><span>Using per mesh:</span><span id="nUsed">â€”</span></div>
    </div>
  </aside>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment.js';

const viewport = document.getElementById('viewport');
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth - 360, window.innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.8;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.physicallyCorrectLights = true;
viewport.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0f0f0);

const camera = new THREE.PerspectiveCamera(50, (window.innerWidth - 360)/window.innerHeight, 0.001, 1000);
camera.position.set(2.5, 1.6, 3.2);
const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, 1, 0);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.minDistance = 0.1;
controls.maxDistance = 100;
controls.zoomSpeed = 1.2;
controls.panSpeed = 0.8;
controls.rotateSpeed = 0.5;
controls.update();

// Enhanced lighting
const ambient = new THREE.AmbientLight(0xffffff, 1.5);
scene.add(ambient);
const keyLight = new THREE.DirectionalLight(0xffffff, 3.5);
keyLight.position.set(4, 5, 3);
keyLight.castShadow = true;
keyLight.shadow.mapSize.set(2048, 2048);
keyLight.shadow.camera.near = 0.1;
keyLight.shadow.camera.far = 50;
keyLight.shadow.normalBias = 0.02;
scene.add(keyLight);
const fillLight = new THREE.DirectionalLight(0xffffff, 2.0);
fillLight.position.set(-5, 2, 2);
scene.add(fillLight);
const rimLight = new THREE.DirectionalLight(0xffffff, 2.5);
rimLight.position.set(-2, 4, -3);
scene.add(rimLight);
const topLight = new THREE.DirectionalLight(0xffffff, 2.0);
topLight.position.set(0, 8, 0);
scene.add(topLight);

// PBR environment
const pmremGen = new THREE.PMREMGenerator(renderer);
const envTex = pmremGen.fromScene(new RoomEnvironment(renderer), 0.04).texture;
scene.environment = envTex;

// Ground
const ground = new THREE.Mesh(
  new THREE.CircleGeometry(6, 64),
  new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.0, roughness: 0.95 })
);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// UI Elements
const $ = (id) => document.getElementById(id);
const fileGLB = $('fileGLB');
const fileBlend = $('fileBlend');
const blendStatus = $('blendStatus');
const fileFlow = $('fileFlow');
const flowStatus = $('flowStatus');
const rotStrength = $('rotStrength');
const flowThreshold = $('flowThreshold');
const enableFlow = $('enableFlow');
const invert = $('invert');
const smooth = $('smooth');
const contrast = $('contrast');
const exposure = $('exposure');
const frameBtn = $('frameBtn');
const nDetected = $('nDetected');
const nCap = $('nCap');
const nUsed = $('nUsed');

function syncVals(){ 
  $('smoothVal').textContent = (+smooth.value).toFixed(2);
  $('contrastVal').textContent = (+contrast.value).toFixed(2);
  $('exposureVal').textContent = (+exposure.value).toFixed(2);
  $('rotStrengthVal').textContent = (+rotStrength.value).toFixed(0) + 'Â°';
  $('flowThresholdVal').textContent = (+flowThreshold.value).toFixed(2);
}

['input','change'].forEach(evt => {
  [invert, smooth, contrast, exposure, rotStrength, flowThreshold, enableFlow].forEach(el => {
    el.addEventListener(evt, () => { syncVals(); updateUniforms(); });
  });
});
syncVals();

// Blend map
let blendTex = null;
let flowTex = null;

// Load embedded default grayscale gradient
const canvas = document.createElement('canvas');
canvas.width = 256;
canvas.height = 256;
const ctx = canvas.getContext('2d');
const gradient = ctx.createLinearGradient(0, 0, 256, 0);
gradient.addColorStop(0, 'black');
gradient.addColorStop(1, 'white');
ctx.fillStyle = gradient;
ctx.fillRect(0, 0, 256, 256);
blendTex = new THREE.CanvasTexture(canvas);
blendTex.colorSpace = THREE.NoColorSpace;
blendTex.wrapS = blendTex.wrapT = THREE.RepeatWrapping;
blendTex.minFilter = THREE.LinearFilter;
blendTex.magFilter = THREE.LinearFilter;

// Load custom blend map
fileBlend.addEventListener('change', (e) => {
  const f = e.target.files?.[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  new THREE.TextureLoader().load(url, (tex) => {
  tex.colorSpace = THREE.NoColorSpace;
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping; 
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;
    blendTex = tex;
    blendStatus.textContent = 'loaded';
    for (const sh of shaderRefs) {
      if (sh.uniforms.uBlendTex) sh.uniforms.uBlendTex.value = blendTex;
    }
  });
});

// Load flow map
fileFlow.addEventListener('change', (e) => {
  const f = e.target.files?.[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  new THREE.TextureLoader().load(url, (tex) => {
    tex.colorSpace = THREE.NoColorSpace;
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;
    flowTex = tex;
    flowStatus.textContent = 'loaded';
    for (const sh of shaderRefs) { 
      if (sh.uniforms.uFlowTex) sh.uniforms.uFlowTex.value = flowTex;
      if (sh.uniforms.uHasFlow) sh.uniforms.uHasFlow.value = 1;
    }
  });
});

// Helpers
function makeSolidSRGBTex(color){ 
  const to8 = v => Math.round(Math.pow(THREE.MathUtils.clamp(v,0,1), 1/2.2) * 255);
  const data = new Uint8Array([to8(color.r), to8(color.g), to8(color.b), 255]);
  const tex = new THREE.DataTexture(data, 1, 1, THREE.RGBAFormat);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.needsUpdate = true;
  tex.magFilter = THREE.LinearFilter;
  tex.minFilter = THREE.LinearFilter; 
  return tex;
}

const shaderRefs = [];
let currentRoot = null;
let globalVariantNames = [];

function updateUniforms(){
  const vals = { 
    uInvert: parseInt(invert.value, 10),
    uSmooth: parseFloat(smooth.value),
    uContrast: parseFloat(contrast.value),
    uRotStrength: parseFloat(rotStrength.value) * Math.PI / 180.0,
    uFlowThreshold: parseFloat(flowThreshold.value),
    uEnableFlow: parseInt(enableFlow.value, 10)
  };
  renderer.toneMappingExposure = parseFloat(exposure.value);
  for (const sh of shaderRefs) { 
    if (sh.uniforms.uInvert) sh.uniforms.uInvert.value = vals.uInvert;
    if (sh.uniforms.uSmooth) sh.uniforms.uSmooth.value = vals.uSmooth;
    if (sh.uniforms.uContrast) sh.uniforms.uContrast.value = vals.uContrast;
    if (sh.uniforms.uRotStrength) sh.uniforms.uRotStrength.value = vals.uRotStrength;
    if (sh.uniforms.uFlowThreshold) sh.uniforms.uFlowThreshold.value = vals.uFlowThreshold;
    if (sh.uniforms.uEnableFlow) sh.uniforms.uEnableFlow.value = vals.uEnableFlow;
  }
}

function frameObject(obj) { 
  const box = new THREE.Box3().setFromObject(obj);
  const size = new THREE.Vector3();
  box.getSize(size);
  const center = new THREE.Vector3();
  box.getCenter(center);
  const maxSize = Math.max(size.x, size.y, size.z);
  const fitHeightDistance = maxSize / (2 * Math.atan((Math.PI * camera.fov) / 360));
  const fitWidthDistance = fitHeightDistance / camera.aspect;
  const distance = Math.max(fitHeightDistance, fitWidthDistance);
  const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
  camera.position.copy(dir.multiplyScalar(distance).add(center));
  controls.target.copy(center);
  controls.update();
}

frameBtn?.addEventListener('click', () => { 
  if (currentRoot) frameObject(currentRoot); 
});

// Core: apply variant blend
async function applyVariantBlend(mesh, gltf) { 
  const ext = mesh.userData?.gltfExtensions?.['KHR_materials_variants'];
  if (!ext || !ext.mappings) return false;

  const parser = gltf.parser;
  const Nfile = Math.max(2, globalVariantNames.length);
  nDetected.textContent = String(Nfile);

  const texUnits = renderer.capabilities.maxTextures || 8;
  const SAMPLER_CAP = Math.max(2, texUnits - 4);
  nCap.textContent = String(SAMPLER_CAP);
  const NUsed = Math.min(Nfile, SAMPLER_CAP);
  nUsed.textContent = String(NUsed);

  // Get variant materials
  const mats = new Array(NUsed).fill(mesh.material);
  for (const mapping of ext.mappings) { 
    for (const vidx of mapping.variants) {
      if (vidx < NUsed) {
        mats[vidx] = await parser.getDependency('material', mapping.material);
      }
    }
  }

  const baseTex = mats.map(m => m.map ? m.map : makeSolidSRGBTex((m.color || new THREE.Color(1,1,1)).clone()));
  const roughArr = new Float32Array(mats.map(m => (typeof m.roughness === 'number') ? m.roughness : 1.0));
  const metalArr = new Float32Array(mats.map(m => (typeof m.metalness === 'number') ? m.metalness : 0.0));

  const origMat = mesh.material;
  const normalTex = origMat.normalMap || null;
  const normalScale = (origMat.normalScale && origMat.normalScale.x) ? origMat.normalScale.x : 1.0;

  const mat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    metalness: 1.0,
    roughness: 1.0,
    normalMap: normalTex
  });
  mat.normalScale = new THREE.Vector2(normalScale, normalScale);
  mat.defines = Object.assign({}, mat.defines, { USE_UV: '' });

  mat.onBeforeCompile = (shader) => { 
    // Blend uniforms
    shader.uniforms.uBlendTex = { value: blendTex };
    shader.uniforms.uInvert = { value: parseInt(invert.value, 10) };
    shader.uniforms.uSmooth = { value: parseFloat(smooth.value) };
    shader.uniforms.uContrast = { value: parseFloat(contrast.value) };
    
    // Flow uniforms
    shader.uniforms.uFlowTex = { value: flowTex };
    shader.uniforms.uHasFlow = { value: flowTex ? 1 : 0 };
    shader.uniforms.uRotStrength = { value: parseFloat(rotStrength.value) * Math.PI / 180.0 };
    shader.uniforms.uFlowThreshold = { value: parseFloat(flowThreshold.value) };
    shader.uniforms.uEnableFlow = { value: parseInt(enableFlow.value, 10) };

    // Variant uniforms
    shader.uniforms.uN = { value: NUsed };
    shader.uniforms.uRoughArr = { value: roughArr };
    shader.uniforms.uMetalArr = { value: metalArr };
    for (let j=0; j<NUsed; j++) {
      shader.uniforms['uBase'+j] = { value: baseTex[j] };
    }

    // GLSL snippets
    let samplerDecl = '';
    for (let i=0; i<NUsed; i++) samplerDecl += `uniform sampler2D uBase${i};\n`;
    
    // Lapped texture method: rotate texture sampling per variant
    let pickFn = `vec3 baseAt(int k, vec2 uv, float angle){\n`;
    pickFn += `  vec2 rotUv = rotateUV(uv, angle, vec2(0.5, 0.5));\n`;
    pickFn += `  vec3 c = pow(texture2D(uBase0, rotUv).rgb, vec3(2.2));\n  if (k==0) return c;\n`;
    for (let i=1; i<NUsed-1; i++) {
      pickFn += `  c = pow(texture2D(uBase${i}, rotUv).rgb, vec3(2.2));\n  if (k==${i}) return c;\n`;
    }
    pickFn += `  return pow(texture2D(uBase${NUsed-1}, rotUv).rgb, vec3(2.2));\n}`;

    shader.fragmentShader = shader.fragmentShader
      .replace('#include <common>', `#include <common>
        uniform sampler2D uBlendTex;
        uniform sampler2D uFlowTex;
        uniform int   uHasFlow;
        uniform int   uEnableFlow;
        uniform float uRotStrength;
        uniform float uFlowThreshold;
        uniform int   uInvert;
        uniform float uSmooth;
        uniform float uContrast;
        uniform int   uN;
        uniform float uRoughArr[${NUsed}];
        uniform float uMetalArr[${NUsed}];
        ${samplerDecl}

        float contrast01(float x, float k){ return pow(clamp(x,0.0,1.0), max(k, 0.0001)); }

        vec2 rotateUV(vec2 uv, float angle, vec2 center){
          float ca = cos(angle);
          float sa = sin(angle);
          mat2 R = mat2(ca, -sa, sa, ca);
          return R * (uv - center) + center;
        }

        ${pickFn}

        void blendN_byIntensity(vec2 uv, float inten, float rotAngle, out vec3 baseLin, out float rough, out float metal){
          float seg = float(uN - 1);
          float x = clamp(inten, 0.0, 1.0) * seg;
          int i = int(floor(x));
          i = clamp(i, 0, uN-2);
          float t = fract(x);
          float u = mix(t, smoothstep(0.0, 1.0, t), uSmooth);
          // Lapped texture: rotate texture samples
          vec3 a = baseAt(i, uv, rotAngle);
          vec3 b = baseAt(i+1, uv, rotAngle);
          baseLin = mix(a, b, u);
          rough   = mix(uRoughArr[i], uRoughArr[i+1], u);
          metal   = mix(uMetalArr[i], uMetalArr[i+1], u);
        }
      `)
      .replace('#include <map_fragment>', `
        vec4 blendSample = texture2D(uBlendTex, vUv);
        float inten = dot(blendSample.rgb, vec3(0.2126, 0.7152, 0.0722));
        inten = (uInvert == 1) ? (1.0 - inten) : inten;
        inten = contrast01(inten, uContrast);

        // Flow map rotation (lapped texture method)
        float rotAngle = 0.0;
        if (uHasFlow == 1 && uEnableFlow == 1) {
          vec4 flowSample = texture2D(uFlowTex, vUv);
          // Check if flow is valid (not black/transparent)
          float flowMag = length(flowSample.rg - vec2(0.5));
          float flowAlpha = flowSample.a;
          float isValid = step(uFlowThreshold, flowMag) * step(uFlowThreshold, flowAlpha);
          vec2 flowDir = flowSample.rg * 2.0 - 1.0;
          float angle = atan(flowDir.y, flowDir.x);
          rotAngle = angle * uRotStrength * isValid;
        }

        vec3 _base;
        float _rough;
        float _metal;
        blendN_byIntensity(vUv, inten, rotAngle, _base, _rough, _metal);
        diffuseColor.rgb *= _base;
      `)
      .replace('#include <roughnessmap_fragment>', `#include <roughnessmap_fragment>
        roughnessFactor = clamp(_rough, 0.04, 1.0);
      `)
      .replace('#include <metalnessmap_fragment>', `#include <metalnessmap_fragment>
        metalnessFactor = clamp(_metal, 0.0, 1.0);
      `);

    mesh.userData._shader = shader;
    if (!shaderRefs.includes(shader)) shaderRefs.push(shader);
  };

  mesh.material = mat;
  return true;
}

// Loader
const loader = new GLTFLoader();
fileGLB.addEventListener('change', (e) => { 
  const file = e.target.files?.[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  loader.load(url, async (gltf) => { 
    shaderRefs.length = 0;
    if (currentRoot) scene.remove(currentRoot);
    const root = gltf.scene || gltf.scenes[0];
    currentRoot = root;
    scene.add(root);

    // Shadows
    root.traverse(o => {
      if (o.isMesh) {
        o.castShadow = true;
        o.receiveShadow = true;
      }
    });

    // Global variants
    const extRoot = gltf.userData?.gltfExtensions?.['KHR_materials_variants'];
    globalVariantNames = extRoot?.variants?.map(v => v.name) || [];
    nDetected.textContent = globalVariantNames.length ? String(globalVariantNames.length) : '0';

    // Apply to meshes
    const tasks = [];
    root.traverse(o => {
      if (o.isMesh) tasks.push(applyVariantBlend(o, gltf));
    });
    await Promise.all(tasks);
    updateUniforms();
    frameObject(root);
  });
});

// Render loop
function tick(){
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
tick();

// Resize
window.addEventListener('resize', () => { 
  renderer.setSize(window.innerWidth - 360, window.innerHeight);
  camera.aspect = (window.innerWidth - 360)/window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>

