<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced Multi-Layer Paint System with GLB Support</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: linear-gradient(180deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; color: #fff; overflow: hidden; }
    #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; z-index: 1000; }
    
    /* Left UI Panel */
    #ui-left { position: fixed; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 12px; z-index: 100; max-width: 340px; }
    
    /* Right UI Panel */
    #ui-right { position: fixed; top: 20px; right: 20px; display: flex; flex-direction: column; gap: 12px; z-index: 100; max-width: 340px; }
    
    .ui-group { background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); border-radius: 12px; padding: 14px; border: 1px solid rgba(255,255,255,0.1); }
    .ui-title { font-size: 11px; font-weight: bold; margin-bottom: 10px; color: #00ff88; text-transform: uppercase; letter-spacing: 1.5px; }
    button { width: 100%; padding: 10px; border: 0; border-radius: 8px; background: linear-gradient(135deg, #00ff88 0%, #00ccff 100%); color: #000; cursor: pointer; font-weight: 600; transition: all 0.3s; margin-bottom: 6px; font-size: 13px; }
    button:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4); }
    button.secondary { background: rgba(255,255,255,0.1); color: #fff; }
    button.secondary:hover { background: rgba(255,255,255,0.2); }
    button.active { background: linear-gradient(135deg, #ff0055 0%, #ff9a00 100%); color: #fff; }
    button.export { background: linear-gradient(135deg, #9333ea 0%, #4f46e5 100%); color: #fff; }
    .slider-container { margin: 10px 0; }
    .slider-label { font-size: 11px; margin-bottom: 6px; display: flex; justify-content: space-between; color: #00ff88; }
    input[type="range"] { width: 100%; height: 6px; border-radius: 3px; background: rgba(0,255,136,0.2); outline: none; -webkit-appearance: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #00ff88; cursor: pointer; box-shadow: 0 0 10px rgba(0,255,136,0.5); }
    input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #00ff88; cursor: pointer; border: none; box-shadow: 0 0 10px rgba(0,255,136,0.5); }
    select { width: 100%; padding: 8px; border: 1px solid rgba(0,255,136,0.3); border-radius: 6px; background: rgba(0,0,0,0.8); color: #00ff88; font-size: 12px; margin-bottom: 8px; }
    
    /* File input styling */
    .file-input-wrapper { position: relative; overflow: hidden; display: inline-block; width: 100%; }
    .file-input-wrapper input[type=file] { position: absolute; left: -9999px; }
    .file-input-label { display: block; width: 100%; padding: 10px; border: 2px dashed rgba(0,255,136,0.3); border-radius: 8px; text-align: center; cursor: pointer; transition: all 0.3s; background: rgba(0,255,136,0.05); }
    .file-input-label:hover { border-color: rgba(0,255,136,0.6); background: rgba(0,255,136,0.1); }
    
    #info { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.85); padding: 16px; border-radius: 12px; font-size: 12px; backdrop-filter: blur(10px); max-width: 400px; border: 1px solid rgba(0,255,136,0.2); }
    #stats { position: fixed; bottom: 20px; right: 20px; background: rgba(0,0,0,0.85); padding: 16px; border-radius: 12px; font-size: 12px; backdrop-filter: blur(10px); border: 1px solid rgba(0,255,136,0.2); min-width: 220px; }
    .stat-item { display: flex; justify-content: space-between; margin: 6px 0; }
    .stat-label { color: #00ff88; }
    .stat-value { font-weight: bold; color: #00ccff; }
    canvas { display: block; }
    #exportNotification {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #00ff88 0%, #00ccff 100%);
      color: #000; padding: 20px 30px; border-radius: 12px;
      font-weight: bold; z-index: 2000; display: none;
      box-shadow: 0 10px 40px rgba(0,255,136,0.5);
    }
    
    .paint-layer-indicator {
      display: flex; gap: 8px; margin-top: 8px;
      font-size: 10px; align-items: center;
    }
    .layer-dot {
      width: 12px; height: 12px; border-radius: 50%;
      display: inline-block;
    }
  </style>
</head>
<body>
  <div id="loading">Loading Physics Engine...</div>
  <div id="exportNotification">Export Complete!</div>

  <!-- Left UI Panel -->
  <div id="ui-left" style="display:none;">
    <div class="ui-group">
      <div class="ui-title">üéØ Drop Objects</div>
      <button id="dropSphere">Sphere</button>
      <button id="dropBox">Box</button>
      <button id="dropCylinder">Cylinder</button>
      <button id="dropCone">Cone</button>
      <button id="dropTorus">Torus</button>
      <button id="dropCompound">Compound</button>
    </div>

    <div class="ui-group">
      <div class="ui-title">üì¶ Load GLB Model</div>
      <div class="file-input-wrapper">
        <input type="file" id="glbInput" accept=".glb,.gltf">
        <label for="glbInput" class="file-input-label">
          Click to load GLB/GLTF
        </label>
      </div>
      <button id="dropLoadedModel" class="secondary" style="display:none;">Drop Loaded Model</button>
    </div>

    <div class="ui-group">
      <div class="ui-title">‚öôÔ∏è Physics</div>
      <div class="slider-container"><div class="slider-label"><span>Restitution</span><span id="restitutionValue">0.3</span></div><input type="range" id="restitutionSlider" min="0" max="100" value="30"></div>
      <div class="slider-container"><div class="slider-label"><span>Friction</span><span id="frictionValue">0.5</span></div><input type="range" id="frictionSlider" min="0" max="100" value="50"></div>
      <div class="slider-container"><div class="slider-label"><span>Gravity</span><span id="gravityValue">9.8</span></div><input type="range" id="gravitySlider" min="0" max="300" value="98"></div>
    </div>
  </div>

  <!-- Right UI Panel -->
  <div id="ui-right" style="display:none;">
    <div class="ui-group">
      <div class="ui-title">üñåÔ∏è Multi-Layer Paint</div>
      <button id="togglePrecise" class="active">Precise Mode: ON</button>
      <button id="toggleSlipPaint" class="active">Slip Paint: ON</button>
      <button id="toggleImpactPaint" class="active">Impact Paint: ON</button>
      <button id="toggleVector" class="active">Vector Field: ON</button>
      
      <div class="paint-layer-indicator">
        <span>Layers:</span>
        <span class="layer-dot" style="background: #00ff88;" title="Slip paint"></span>
        <span>Slip</span>
        <span class="layer-dot" style="background: #ff0055;" title="Impact paint"></span>
        <span>Impact</span>
        <span class="layer-dot" style="background: #00ccff;" title="Vector field"></span>
        <span>Vector</span>
      </div>
      
      <div class="slider-container"><div class="slider-label"><span>Slip Sensitivity</span><span id="slipSensValue">0.05</span></div><input type="range" id="slipSens" min="1" max="100" value="5"></div>
      <div class="slider-container"><div class="slider-label"><span>Impact Threshold</span><span id="impactThresholdValue">5.0</span></div><input type="range" id="impactThreshold" min="10" max="200" value="50"></div>
      <div class="slider-container"><div class="slider-label"><span>Gaussian Spread</span><span id="gaussianSpreadValue">1.0</span></div><input type="range" id="gaussianSpread" min="10" max="300" value="100"></div>
      <div class="slider-container"><div class="slider-label"><span>Paint Opacity</span><span id="paintOpacityValue">0.8</span></div><input type="range" id="paintOpacity" min="10" max="100" value="80"></div>
      
      <button id="clearPaint" class="secondary">Clear All Layers</button>
      <button id="reset" class="secondary">Reset Scene</button>
    </div>

    <div class="ui-group">
      <div class="ui-title">üíæ Export</div>
      <button id="exportSlipLayer" class="export">Export Slip Layer</button>
      <button id="exportImpactLayer" class="export">Export Impact Layer</button>
      <button id="exportComposite" class="export">Export Composite</button>
      <button id="exportVector" class="export">Export Vector Field</button>
      <button id="exportData" class="export">Export Scene Data</button>
    </div>
  </div>

  <div id="info" style="display:none;">
    ‚ö° <b>Multi-Layer Paint System</b><br>
    ‚Ä¢ <b>Slip Layer:</b> Continuous paint from sliding friction<br>
    ‚Ä¢ <b>Impact Layer:</b> High-pressure single impacts<br>
    ‚Ä¢ <b>Vector Field:</b> Directional flow accumulation<br>
    ‚Ä¢ <b>Ctrl + Drag:</b> Grab and move objects (Q/E for height)<br>
    ‚Ä¢ Supports GLB/GLTF models with textures
  </div>

  <div id="stats" style="display:none;">
    <div class="stat-item"><span class="stat-label">Bodies:</span><span class="stat-value" id="bodyCount">0</span></div>
    <div class="stat-item"><span class="stat-label">Slip Points:</span><span class="stat-value" id="slipCount">0</span></div>
    <div class="stat-item"><span class="stat-label">Impacts:</span><span class="stat-value" id="impactCount">0</span></div>
    <div class="stat-item"><span class="stat-label">Vector Cells:</span><span class="stat-value" id="vectorCount">0</span></div>
    <div class="stat-item"><span class="stat-label">FPS:</span><span class="stat-value" id="fps">60</span></div>
    <div class="stat-item"><span class="stat-label">Physics Hz:</span><span class="stat-value" id="physicsHz">0</span></div>
  </div>

  <script src="https://cdn.jsdelivr.net/gh/kripken/ammo.js@main/builds/ammo.js"></script>
  <script type="importmap">{ 
    "imports": { 
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js", 
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" 
    } 
  }</script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';

    Ammo().then(function(Ammo) {
      // Configuration
      let preciseMode = true;
      let slipPaintEnabled = true;
      let impactPaintEnabled = true;
      let vectorFieldEnabled = true;
      
      let SLIP_SENSITIVITY = 0.05;
      let IMPACT_THRESHOLD = 5.0;
      let GAUSSIAN_SPREAD = 1.0;
      let PAINT_OPACITY = 0.8;
      
      document.getElementById('loading').style.display = 'none';
      document.getElementById('ui-left').style.display = 'flex';
      document.getElementById('ui-right').style.display = 'flex';
      document.getElementById('info').style.display = 'block';
      document.getElementById('stats').style.display = 'block';

      // Physics setup
      const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
      const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
      const overlappingPairCache = new Ammo.btDbvtBroadphase();
      const solver = new Ammo.btSequentialImpulseConstraintSolver();
      const physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
      physicsWorld.setGravity(new Ammo.btVector3(0, -9.8, 0));

      // Three.js setup
      const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x16213e, 20, 80);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(15, 12, 15);
      camera.lookAt(0, 0, 0);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI * 0.49;
      controls.minDistance = 5;
      controls.maxDistance = 50;

      // Lighting
      scene.add(new THREE.AmbientLight(0x404040, 0.8));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
      dirLight.position.set(10, 20, 10);
      dirLight.castShadow = true;
      dirLight.shadow.camera.near = 0.1;
      dirLight.shadow.camera.far = 60;
      dirLight.shadow.camera.left = -25;
      dirLight.shadow.camera.right = 25;
      dirLight.shadow.camera.top = 25;
      dirLight.shadow.camera.bottom = -25;
      dirLight.shadow.mapSize.set(2048, 2048);
      scene.add(dirLight);

      const pointLight1 = new THREE.PointLight(0x00ff88, 0.5, 40);
      pointLight1.position.set(-15, 15, -15);
      scene.add(pointLight1);

      const colors = [0x00ff88, 0x00ccff, 0xff0055, 0xffaa00, 0xff00ff, 0x88ff00, 0x0088ff, 0xff8800, 0x8800ff, 0xffff00];
      let physicsParams = { restitution: 0.3, friction: 0.5 };

      const rigidBodies = [];
      const tmpTrans = new Ammo.btTransform();
      
      let totalSlipPoints = 0;
      let totalImpacts = 0;
      let activeVectorCells = 0;
      let physicsSteps = 0;

      // GLB Loader
      const gltfLoader = new GLTFLoader();
      let loadedModel = null;

      // Ground setup
      const groundSize = 50;
      const groundGeo = new THREE.BoxGeometry(groundSize, 2, groundSize);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2e, roughness: 0.9, metalness: 0.0 });
      const groundMesh = new THREE.Mesh(groundGeo, groundMat);
      groundMesh.position.y = -1;
      groundMesh.receiveShadow = true;
      scene.add(groundMesh);

      const grid = new THREE.GridHelper(groundSize, 50, 0x00ff88, 0x003344);
      grid.position.y = 0.005;
      scene.add(grid);

      // Multiple paint layers
      const PAINT_RES = 2048;
      
      // Slip paint layer (continuous)
      const slipCanvas = document.createElement('canvas');
      slipCanvas.width = PAINT_RES;
      slipCanvas.height = PAINT_RES;
      const slipCtx = slipCanvas.getContext('2d', { willReadFrequently: false });
      slipCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);

      const slipTex = new THREE.CanvasTexture(slipCanvas);
      slipTex.flipY = true;
      slipTex.wrapS = slipTex.wrapT = THREE.ClampToEdgeWrapping;
      slipTex.needsUpdate = true;

      // Impact paint layer (single impacts)
      const impactCanvas = document.createElement('canvas');
      impactCanvas.width = PAINT_RES;
      impactCanvas.height = PAINT_RES;
      const impactCtx = impactCanvas.getContext('2d', { willReadFrequently: false });
      impactCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);

      const impactTex = new THREE.CanvasTexture(impactCanvas);
      impactTex.flipY = true;
      impactTex.wrapS = impactTex.wrapT = THREE.ClampToEdgeWrapping;
      impactTex.needsUpdate = true;

      // Composite paint plane
      const paintMaterial = new THREE.ShaderMaterial({
        uniforms: {
          slipTexture: { value: slipTex },
          impactTexture: { value: impactTex },
          slipOpacity: { value: 1.0 },
          impactOpacity: { value: 1.0 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D slipTexture;
          uniform sampler2D impactTexture;
          uniform float slipOpacity;
          uniform float impactOpacity;
          varying vec2 vUv;
          
          void main() {
            vec4 slip = texture2D(slipTexture, vUv);
            vec4 impact = texture2D(impactTexture, vUv);
            
            // Composite layers
            vec4 color = vec4(0.0);
            color = mix(color, slip, slip.a * slipOpacity);
            color = mix(color, impact, impact.a * impactOpacity);
            
            gl_FragColor = color;
          }
        `,
        transparent: true,
        depthWrite: false
      });

      const paintPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(groundSize, groundSize),
        paintMaterial
      );
      paintPlane.rotation.x = -Math.PI / 2;
      paintPlane.position.y = 0.011;
      scene.add(paintPlane);

      // Vector field
      const VECTOR_GRID = 64;
      const vectorField = new Float32Array(VECTOR_GRID * VECTOR_GRID * 5);
      const vectorCanvas = document.createElement('canvas');
      vectorCanvas.width = 512;
      vectorCanvas.height = 512;
      const vectorCtx = vectorCanvas.getContext('2d');

      // Ground physics body
      const groundShape = new Ammo.btBoxShape(new Ammo.btVector3(groundSize / 2, 1, groundSize / 2));
      const groundTransform = new Ammo.btTransform();
      groundTransform.setIdentity();
      groundTransform.setOrigin(new Ammo.btVector3(0, -1, 0));
      const groundMotionState = new Ammo.btDefaultMotionState(groundTransform);
      const groundRbInfo = new Ammo.btRigidBodyConstructionInfo(0, groundMotionState, groundShape, new Ammo.btVector3(0, 0, 0));
      groundRbInfo.set_m_restitution(0.3);
      groundRbInfo.set_m_friction(0.5);
      const groundBody = new Ammo.btRigidBody(groundRbInfo);
      physicsWorld.addRigidBody(groundBody);
      groundMesh.userData.physicsBody = groundBody;

      // Contact tracking
      const contactHistory = new Map();
      const impactHistory = new Set();

      // Smoothstep function
      function smoothstep(edge0, edge1, x) {
        const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
        return t * t * (3 - 2 * t);
      }

      // Compute slip velocity
      function computeSlipVelocity(body, contactPoint, normal) {
        const v = body.getLinearVelocity();
        const w = body.getAngularVelocity();
        body.getMotionState().getWorldTransform(tmpTrans);
        const pos = tmpTrans.getOrigin();
        
        const r = new THREE.Vector3(
          contactPoint.x - pos.x(),
          contactPoint.y - pos.y(),
          contactPoint.z - pos.z()
        );
        
        const contactVel = new THREE.Vector3(
          v.x() + w.y() * r.z - w.z() * r.y,
          v.y() + w.z() * r.x - w.x() * r.z,
          v.z() + w.x() * r.y - w.y() * r.x
        );
        
        const normalVel = normal.clone().multiplyScalar(contactVel.dot(normal));
        const slipVel = contactVel.clone().sub(normalVel);
        
        return { slipVel, speed: slipVel.length(), contactVel };
      }

      // Gaussian paint based on slip/speed/pressure
      function drawGaussianSlipPaint(worldPoint, slipSpeed, pressure, color) {
        const u = THREE.MathUtils.clamp((worldPoint.x + groundSize / 2) / groundSize, 0, 1);
        const v = THREE.MathUtils.clamp((worldPoint.z + groundSize / 2) / groundSize, 0, 1);
        const px = u * PAINT_RES;
        const py = v * PAINT_RES;
        
        // Gaussian spread based on slip speed and pressure
        const baseRadius = 0.05 + slipSpeed * 0.02 + pressure * 0.001;
        const spread = baseRadius * GAUSSIAN_SPREAD;
        const rpx = Math.max(2, (spread / groundSize) * PAINT_RES);
        
        const c = new THREE.Color(color);
        const intensity = smoothstep(0, 1, slipSpeed * 10) * PAINT_OPACITY;
        
        slipCtx.save();
        slipCtx.globalCompositeOperation = 'lighter';
        slipCtx.filter = `blur(${rpx * 0.2}px)`;
        
        const g = slipCtx.createRadialGradient(px, py, 0, px, py, rpx);
        g.addColorStop(0, `rgba(${(c.r * 255) | 0},${(c.g * 255) | 0},${(c.b * 255) | 0},${intensity})`);
        g.addColorStop(0.3, `rgba(${(c.r * 255) | 0},${(c.g * 255) | 0},${(c.b * 255) | 0},${intensity * 0.7})`);
        g.addColorStop(0.6, `rgba(${(c.r * 255) | 0},${(c.g * 255) | 0},${(c.b * 255) | 0},${intensity * 0.3})`);
        g.addColorStop(1, `rgba(${(c.r * 255) | 0},${(c.g * 255) | 0},${(c.b * 255) | 0},0)`);
        
        slipCtx.fillStyle = g;
        slipCtx.beginPath();
        slipCtx.arc(px, py, rpx, 0, Math.PI * 2);
        slipCtx.fill();
        slipCtx.restore();
        
        slipTex.needsUpdate = true;
        totalSlipPoints++;
      }

      // Impact paint for hard single impacts
      function drawImpactPaint(worldPoint, impulse, color) {
        const u = THREE.MathUtils.clamp((worldPoint.x + groundSize / 2) / groundSize, 0, 1);
        const v = THREE.MathUtils.clamp((worldPoint.z + groundSize / 2) / groundSize, 0, 1);
        const px = u * PAINT_RES;
        const py = v * PAINT_RES;
        
        // Impact size based on impulse
        const radius = Math.min(0.5, 0.1 + impulse * 0.02);
        const rpx = Math.max(5, (radius / groundSize) * PAINT_RES);
        
        // Different color for impacts (redder/darker)
        const c = new THREE.Color(color);
        c.r = Math.min(1, c.r * 1.5);
        c.g *= 0.5;
        c.b *= 0.5;
        
        impactCtx.save();
        impactCtx.globalCompositeOperation = 'screen';
        
        // Star burst pattern for impacts
        const spikes = 8;
        const outerRadius = rpx;
        const innerRadius = rpx * 0.5;
        
        impactCtx.fillStyle = `rgba(${(c.r * 255) | 0},${(c.g * 255) | 0},${(c.b * 255) | 0},0.9)`;
        impactCtx.beginPath();
        for (let i = 0; i < spikes * 2; i++) {
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const angle = (i / (spikes * 2)) * Math.PI * 2;
          const x = px + Math.cos(angle) * radius;
          const y = py + Math.sin(angle) * radius;
          if (i === 0) impactCtx.moveTo(x, y);
          else impactCtx.lineTo(x, y);
        }
        impactCtx.closePath();
        impactCtx.fill();
        
        // Central bright spot
        const g = impactCtx.createRadialGradient(px, py, 0, px, py, innerRadius);
        g.addColorStop(0, `rgba(255,255,255,0.8)`);
        g.addColorStop(0.5, `rgba(${(c.r * 255) | 0},${(c.g * 255) | 0},${(c.b * 255) | 0},0.5)`);
        g.addColorStop(1, `rgba(${(c.r * 255) | 0},${(c.g * 255) | 0},${(c.b * 255) | 0},0)`);
        
        impactCtx.fillStyle = g;
        impactCtx.beginPath();
        impactCtx.arc(px, py, innerRadius, 0, Math.PI * 2);
        impactCtx.fill();
        
        impactCtx.restore();
        
        impactTex.needsUpdate = true;
        totalImpacts++;
      }

      // Update vector field
      function updateVectorField(worldPoint, velocity, strength) {
        if (!vectorFieldEnabled || velocity.length() < 0.01) return;
        
        const u = THREE.MathUtils.clamp((worldPoint.x + groundSize / 2) / groundSize, 0, 1);
        const v = THREE.MathUtils.clamp((worldPoint.z + groundSize / 2) / groundSize, 0, 1);
        const i = Math.floor(u * (VECTOR_GRID - 1));
        const j = Math.floor(v * (VECTOR_GRID - 1));
        const idx = (j * VECTOR_GRID + i) * 5;
        
        const weight = strength * 0.1;
        vectorField[idx] += velocity.x * weight;
        vectorField[idx + 1] += velocity.z * weight;
        vectorField[idx + 2] = Math.min(3, vectorField[idx + 2] + weight);
        
        activeVectorCells++;
      }

      // Render vector field
      function renderVectorField() {
        vectorCtx.clearRect(0, 0, 512, 512);
        
        for (let j = 0; j < VECTOR_GRID; j++) {
          for (let i = 0; i < VECTOR_GRID; i++) {
            const idx = (j * VECTOR_GRID + i) * 5;
            const vx = vectorField[idx];
            const vz = vectorField[idx + 1];
            const strength = vectorField[idx + 2];
            
            if (strength < 0.01) continue;
            
            const speed = Math.hypot(vx, vz);
            if (speed < 0.01) continue;
            
            const cx = (i + 0.5) / VECTOR_GRID * 512;
            const cy = (j + 0.5) / VECTOR_GRID * 512;
            const scale = Math.min(15, speed * 30);
            const ex = cx + (vx / speed) * scale;
            const ey = cy + (vz / speed) * scale;
            
            const hue = (Math.atan2(vz, vx) + Math.PI) / (Math.PI * 2) * 360;
            const opacity = Math.min(1, 0.3 + strength * 0.3);
            
            vectorCtx.strokeStyle = `hsla(${hue}, 90%, 55%, ${opacity})`;
            vectorCtx.lineWidth = 2;
            vectorCtx.lineCap = 'round';
            vectorCtx.beginPath();
            vectorCtx.moveTo(cx, cy);
            vectorCtx.lineTo(ex, ey);
            vectorCtx.stroke();
          }
        }
      }

      // Process contacts
      function processContacts() {
        const numManifolds = dispatcher.getNumManifolds();
        
        for (let i = 0; i < numManifolds; i++) {
          const manifold = dispatcher.getManifoldByIndexInternal(i);
          const body0 = Ammo.castObject(manifold.getBody0(), Ammo.btRigidBody);
          const body1 = Ammo.castObject(manifold.getBody1(), Ammo.btRigidBody);
          const numContacts = manifold.getNumContacts();
          
          let mesh0 = null, mesh1 = null;
          for (const rb of rigidBodies) {
            if (rb.userData.physicsBody === body0) mesh0 = rb;
            if (rb.userData.physicsBody === body1) mesh1 = rb;
          }
          if (groundMesh.userData.physicsBody === body0) mesh0 = groundMesh;
          if (groundMesh.userData.physicsBody === body1) mesh1 = groundMesh;
          if (!mesh0 || !mesh1) continue;
          
          for (let j = 0; j < numContacts; j++) {
            const cp = manifold.getContactPoint(j);
            const distance = cp.getDistance();
            
            if (distance < 0.01) {
              const ptA = cp.getPositionWorldOnA();
              const ptB = cp.getPositionWorldOnB();
              const nB = cp.get_m_normalWorldOnB();
              const impulse = cp.getAppliedImpulse();
              
              const paintOn1 = (mesh0 !== groundMesh);
              const point = new THREE.Vector3(
                paintOn1 ? ptB.x() : ptA.x(),
                paintOn1 ? ptB.y() : ptA.y(),
                paintOn1 ? ptB.z() : ptA.z()
              );
              const normal = new THREE.Vector3(nB.x(), nB.y(), nB.z());
              const dynamicBody = paintOn1 ? body0 : body1;
              const dynamicMesh = paintOn1 ? mesh0 : mesh1;
              const surfaceMesh = paintOn1 ? mesh1 : mesh0;
              
              if (surfaceMesh !== groundMesh) continue;
              
              // Calculate slip
              const { slipVel, speed, contactVel } = computeSlipVelocity(dynamicBody, point, normal);
              
              // Check for high impact
              const contactKey = `${Ammo.getPointer(dynamicBody)}_${point.x.toFixed(1)}_${point.z.toFixed(1)}`;
              const isNewImpact = !impactHistory.has(contactKey);
              
              if (impulse > IMPACT_THRESHOLD && isNewImpact && impactPaintEnabled) {
                drawImpactPaint(point, impulse, dynamicMesh.userData.color || 0xff0055);
                impactHistory.add(contactKey);
                
                // Clear old impacts
                if (impactHistory.size > 100) {
                  const firstKey = impactHistory.values().next().value;
                  impactHistory.delete(firstKey);
                }
              }
              
              // Slip paint
              if (speed > SLIP_SENSITIVITY && slipPaintEnabled) {
                if (!preciseMode || Math.random() < 0.5) { // Reduce frequency in non-precise mode
                  drawGaussianSlipPaint(point, speed, impulse, dynamicMesh.userData.color || 0x00ff88);
                }
              }
              
              // Update vector field
              updateVectorField(point, slipVel, impulse);
            }
          }
        }
      }

      // Create rigid body
      function createRigidBody(mesh, shape, mass, pos, quat) {
        const transform = new Ammo.btTransform();
        transform.setIdentity();
        transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
        transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
        const motionState = new Ammo.btDefaultMotionState(transform);
        const localInertia = new Ammo.btVector3(0, 0, 0);
        shape.calculateLocalInertia(mass, localInertia);
        const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
        rbInfo.set_m_restitution(physicsParams.restitution);
        rbInfo.set_m_friction(physicsParams.friction);
        const body = new Ammo.btRigidBody(rbInfo);
        body.setActivationState(4);
        mesh.userData.physicsBody = body;
        scene.add(mesh);
        physicsWorld.addRigidBody(body);
        rigidBodies.push(mesh);
        return body;
      }

      // Create shapes
      function createShape(type) {
        const pos = new THREE.Vector3((Math.random() - 0.5) * 10, 10 + Math.random() * 10, (Math.random() - 0.5) * 10);
        const quat = new THREE.Quaternion();
        const mass = 1 + Math.random() * 2;
        const color = colors[Math.floor(Math.random() * colors.length)];
        let mesh, shape;

        if (type === 'sphere') {
          const r = 0.5 + Math.random() * 0.5;
          mesh = new THREE.Mesh(
            new THREE.SphereGeometry(r, 32, 16),
            new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.2 })
          );
          shape = new Ammo.btSphereShape(r);
        } else if (type === 'box') {
          const s = 0.5 + Math.random() * 0.5;
          mesh = new THREE.Mesh(
            new THREE.BoxGeometry(s * 2, s * 2, s * 2),
            new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.2 })
          );
          shape = new Ammo.btBoxShape(new Ammo.btVector3(s, s, s));
        } else if (type === 'cylinder') {
          const r = 0.5 + Math.random() * 0.3;
          const h = 1 + Math.random() * 0.5;
          mesh = new THREE.Mesh(
            new THREE.CylinderGeometry(r, r, h, 24),
            new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.2 })
          );
          shape = new Ammo.btCylinderShape(new Ammo.btVector3(r, h / 2, r));
        } else if (type === 'cone') {
          const r = 0.5 + Math.random() * 0.3;
          const h = 1 + Math.random() * 0.5;
          mesh = new THREE.Mesh(
            new THREE.ConeGeometry(r, h, 24),
            new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.2 })
          );
          shape = new Ammo.btConeShape(r, h);
        } else if (type === 'torus') {
          const g = new THREE.TorusGeometry(0.6, 0.25, 16, 28);
          mesh = new THREE.Mesh(g, new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.2 }));
          const hull = new Ammo.btConvexHullShape();
          const v = g.attributes.position.array;
          for (let i = 0; i < v.length; i += 3) {
            hull.addPoint(new Ammo.btVector3(v[i], v[i + 1], v[i + 2]), true);
          }
          shape = hull;
        } else if (type === 'compound') {
          const comp = new Ammo.btCompoundShape();
          const group = new THREE.Group();
          for (let i = 0; i < 3; i++) {
            const t = new Ammo.btTransform();
            t.setIdentity();
            const ox = (Math.random() - 0.5) * 1;
            const oy = (Math.random() - 0.5) * 1;
            const oz = (Math.random() - 0.5) * 1;
            t.setOrigin(new Ammo.btVector3(ox, oy, oz));
            const sub = new Ammo.btSphereShape(0.3);
            comp.addChildShape(t, sub);
            const m = new THREE.Mesh(
              new THREE.SphereGeometry(0.3),
              new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.2 })
            );
            m.position.set(ox, oy, oz);
            group.add(m);
          }
          mesh = group;
          shape = comp;
        } else if (type === 'model' && loadedModel) {
          // Create physics shape from loaded model
          mesh = loadedModel.clone();
          
          // Create convex hull from model geometry
          const hull = new Ammo.btConvexHullShape();
          mesh.traverse((child) => {
            if (child.isMesh) {
              const geometry = child.geometry;
              const vertices = geometry.attributes.position.array;
              for (let i = 0; i < vertices.length; i += 3) {
                const v = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
                v.applyMatrix4(child.matrixWorld);
                hull.addPoint(new Ammo.btVector3(v.x, v.y, v.z), true);
              }
            }
          });
          shape = hull;
        } else return;

        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData.color = color;
        
        const body = createRigidBody(mesh, shape, mass, pos, quat);
        const lv = new Ammo.btVector3((Math.random() - 0.5) * 5, 0, (Math.random() - 0.5) * 5);
        body.setLinearVelocity(lv);
        const av = new Ammo.btVector3((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5);
        body.setAngularVelocity(av);
      }

      // GLB file loading
      document.getElementById('glbInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const url = URL.createObjectURL(file);
        gltfLoader.load(url, (gltf) => {
          loadedModel = gltf.scene;
          
          // Normalize size
          const box = new THREE.Box3().setFromObject(loadedModel);
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = 2 / maxDim;
          loadedModel.scale.multiplyScalar(scale);
          
          // Center model
          box.setFromObject(loadedModel);
          const center = box.getCenter(new THREE.Vector3());
          loadedModel.position.sub(center);
          
          // Enable shadows
          loadedModel.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          
          document.getElementById('dropLoadedModel').style.display = 'block';
          console.log('Model loaded successfully');
        });
      });

      document.getElementById('dropLoadedModel').addEventListener('click', () => {
        if (loadedModel) createShape('model');
      });

      // Mouse drag controls
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let dragging = false;
      let dragBody = null;
      let dragMesh = null;
      let dragLocal = null;
      let dragHeight = 0;
      let ctrlDown = false;
      const DRAG_STIFF = 200;
      const DRAG_DAMP = 20;

      function setControlsEnabled() {
        controls.enabled = !(ctrlDown || dragging);
      }

      function screenToWorldOnPlane(clientX, clientY, y) {
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -y);
        const pt = new THREE.Vector3();
        raycaster.ray.intersectPlane(plane, pt);
        return pt;
      }

      window.addEventListener('pointerdown', (e) => {
        if (!e.ctrlKey) return;
        e.preventDefault();
        
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        
        const intersects = raycaster.intersectObjects(rigidBodies, true);
        if (intersects.length) {
          let obj = intersects[0].object;
          while (obj && !obj.userData.physicsBody && obj.parent) obj = obj.parent;
          if (!obj || !obj.userData.physicsBody) return;
          
          dragMesh = obj;
          dragBody = obj.userData.physicsBody;
          dragging = true;
          setControlsEnabled();
          dragBody.activate();
          
          const hit = intersects[0].point.clone();
          dragLocal = hit.clone().applyMatrix4(new THREE.Matrix4().copy(obj.matrixWorld).invert());
          dragHeight = hit.y;
        }
      });

      window.addEventListener('pointermove', (e) => {
        if (!dragging || !dragBody) return;
        
        const worldGrab = dragLocal.clone().applyMatrix4(dragMesh.matrixWorld);
        const target = screenToWorldOnPlane(e.clientX, e.clientY, dragHeight);
        const err = target.sub(worldGrab);
        const force = err.multiplyScalar(DRAG_STIFF);
        
        const f = new Ammo.btVector3(force.x, force.y, force.z);
        dragBody.applyCentralForce(f);
        Ammo.destroy(f);
        
        const lv = dragBody.getLinearVelocity();
        const damp = new Ammo.btVector3(-DRAG_DAMP * lv.x(), -DRAG_DAMP * lv.y(), -DRAG_DAMP * lv.z());
        dragBody.applyCentralForce(damp);
        Ammo.destroy(damp);
      });

      window.addEventListener('pointerup', () => {
        dragging = false;
        dragBody = null;
        dragMesh = null;
        dragLocal = null;
        setControlsEnabled();
      });

      window.addEventListener('keydown', (e) => {
        if (e.key === 'Control') {
          ctrlDown = true;
          setControlsEnabled();
          e.preventDefault();
        }
        if (!dragging) return;
        if (e.key === 'q' || e.key === 'Q') dragHeight -= 0.2;
        if (e.key === 'e' || e.key === 'E') dragHeight += 0.2;
      });

      window.addEventListener('keyup', (e) => {
        if (e.key === 'Control') {
          ctrlDown = false;
          setControlsEnabled();
        }
      });

      // Export functions
      function exportCanvas(canvas, filename) {
        canvas.toBlob(blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.click();
          URL.revokeObjectURL(url);
          
          const notification = document.getElementById('exportNotification');
          notification.style.display = 'block';
          setTimeout(() => {
            notification.style.display = 'none';
          }, 2000);
        });
      }

      function exportComposite() {
        const compositeCanvas = document.createElement('canvas');
        compositeCanvas.width = PAINT_RES;
        compositeCanvas.height = PAINT_RES;
        const ctx = compositeCanvas.getContext('2d');
        
        ctx.drawImage(slipCanvas, 0, 0);
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(impactCanvas, 0, 0);
        
        exportCanvas(compositeCanvas, `composite_${Date.now()}.png`);
      }

      function exportData() {
        const data = {
          timestamp: Date.now(),
          paintResolution: PAINT_RES,
          vectorGridSize: VECTOR_GRID,
          groundSize: groundSize,
          statistics: {
            slipPoints: totalSlipPoints,
            impacts: totalImpacts,
            vectorCells: activeVectorCells,
            bodies: rigidBodies.length
          },
          settings: {
            preciseMode: preciseMode,
            slipSensitivity: SLIP_SENSITIVITY,
            impactThreshold: IMPACT_THRESHOLD,
            gaussianSpread: GAUSSIAN_SPREAD,
            paintOpacity: PAINT_OPACITY
          },
          vectorField: Array.from(vectorField)
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `scene_data_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      // UI Controls
      document.getElementById('dropSphere').addEventListener('click', () => createShape('sphere'));
      document.getElementById('dropBox').addEventListener('click', () => createShape('box'));
      document.getElementById('dropCylinder').addEventListener('click', () => createShape('cylinder'));
      document.getElementById('dropCone').addEventListener('click', () => createShape('cone'));
      document.getElementById('dropTorus').addEventListener('click', () => createShape('torus'));
      document.getElementById('dropCompound').addEventListener('click', () => createShape('compound'));

      document.getElementById('togglePrecise').addEventListener('click', (e) => {
        preciseMode = !preciseMode;
        e.target.classList.toggle('active', preciseMode);
        e.target.textContent = `Precise Mode: ${preciseMode ? 'ON' : 'OFF'}`;
      });

      document.getElementById('toggleSlipPaint').addEventListener('click', (e) => {
        slipPaintEnabled = !slipPaintEnabled;
        e.target.classList.toggle('active', slipPaintEnabled);
        e.target.textContent = `Slip Paint: ${slipPaintEnabled ? 'ON' : 'OFF'}`;
      });

      document.getElementById('toggleImpactPaint').addEventListener('click', (e) => {
        impactPaintEnabled = !impactPaintEnabled;
        e.target.classList.toggle('active', impactPaintEnabled);
        e.target.textContent = `Impact Paint: ${impactPaintEnabled ? 'ON' : 'OFF'}`;
      });

      document.getElementById('toggleVector').addEventListener('click', (e) => {
        vectorFieldEnabled = !vectorFieldEnabled;
        e.target.classList.toggle('active', vectorFieldEnabled);
        e.target.textContent = `Vector Field: ${vectorFieldEnabled ? 'ON' : 'OFF'}`;
      });

      // Physics sliders
      const restitutionSlider = document.getElementById('restitutionSlider');
      const frictionSlider = document.getElementById('frictionSlider');
      const gravitySlider = document.getElementById('gravitySlider');
      
      restitutionSlider.addEventListener('input', () => {
        physicsParams.restitution = (+restitutionSlider.value) / 100;
        document.getElementById('restitutionValue').textContent = physicsParams.restitution.toFixed(2);
        for (const m of rigidBodies) {
          m.userData.physicsBody.setRestitution(physicsParams.restitution);
        }
        groundBody.setRestitution(physicsParams.restitution);
      });

      frictionSlider.addEventListener('input', () => {
        physicsParams.friction = (+frictionSlider.value) / 100;
        document.getElementById('frictionValue').textContent = physicsParams.friction.toFixed(2);
        for (const m of rigidBodies) {
          m.userData.physicsBody.setFriction(physicsParams.friction);
        }
        groundBody.setFriction(physicsParams.friction);
      });

      gravitySlider.addEventListener('input', () => {
        const g = (+gravitySlider.value) / 10;
        document.getElementById('gravityValue').textContent = g.toFixed(1);
        physicsWorld.setGravity(new Ammo.btVector3(0, -g, 0));
      });

      // Paint settings
      document.getElementById('slipSens').addEventListener('input', (e) => {
        SLIP_SENSITIVITY = (+e.target.value) / 100;
        document.getElementById('slipSensValue').textContent = SLIP_SENSITIVITY.toFixed(2);
      });

      document.getElementById('impactThreshold').addEventListener('input', (e) => {
        IMPACT_THRESHOLD = (+e.target.value) / 10;
        document.getElementById('impactThresholdValue').textContent = IMPACT_THRESHOLD.toFixed(1);
      });

      document.getElementById('gaussianSpread').addEventListener('input', (e) => {
        GAUSSIAN_SPREAD = (+e.target.value) / 100;
        document.getElementById('gaussianSpreadValue').textContent = GAUSSIAN_SPREAD.toFixed(1);
      });

      document.getElementById('paintOpacity').addEventListener('input', (e) => {
        PAINT_OPACITY = (+e.target.value) / 100;
        document.getElementById('paintOpacityValue').textContent = PAINT_OPACITY.toFixed(1);
      });

      // Export buttons
      document.getElementById('exportSlipLayer').addEventListener('click', () => {
        exportCanvas(slipCanvas, `slip_layer_${Date.now()}.png`);
      });

      document.getElementById('exportImpactLayer').addEventListener('click', () => {
        exportCanvas(impactCanvas, `impact_layer_${Date.now()}.png`);
      });

      document.getElementById('exportComposite').addEventListener('click', exportComposite);

      document.getElementById('exportVector').addEventListener('click', () => {
        renderVectorField();
        exportCanvas(vectorCanvas, `vector_field_${Date.now()}.png`);
      });

      document.getElementById('exportData').addEventListener('click', exportData);

      document.getElementById('clearPaint').addEventListener('click', () => {
        slipCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);
        slipTex.needsUpdate = true;
        impactCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);
        impactTex.needsUpdate = true;
        vectorField.fill(0);
        totalSlipPoints = 0;
        totalImpacts = 0;
        activeVectorCells = 0;
        contactHistory.clear();
        impactHistory.clear();
      });

      document.getElementById('reset').addEventListener('click', () => {
        for (let i = rigidBodies.length - 1; i >= 0; i--) {
          const m = rigidBodies[i];
          physicsWorld.removeRigidBody(m.userData.physicsBody);
          scene.remove(m);
          rigidBodies.pop();
        }
        slipCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);
        slipTex.needsUpdate = true;
        impactCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);
        impactTex.needsUpdate = true;
        vectorField.fill(0);
        totalSlipPoints = 0;
        totalImpacts = 0;
        activeVectorCells = 0;
        contactHistory.clear();
        impactHistory.clear();
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Animation loop
      const clock = new THREE.Clock();
      let frameCount = 0;
      let lastFps = 0;

      function updatePhysics(dt) {
        const substeps = preciseMode ? 3 : 1;
        const subdt = dt / substeps;
        
        for (let step = 0; step < substeps; step++) {
          physicsWorld.stepSimulation(subdt, 1, 1 / 240);
          processContacts();
          physicsSteps++;
        }
        
        for (let i = 0; i < rigidBodies.length; i++) {
          const mesh = rigidBodies[i];
          const body = mesh.userData.physicsBody;
          if (body && body.getMotionState) {
            body.getMotionState().getWorldTransform(tmpTrans);
            const pos = tmpTrans.getOrigin();
            const quat = tmpTrans.getRotation();
            mesh.position.set(pos.x(), pos.y(), pos.z());
            mesh.quaternion.set(quat.x(), quat.y(), quat.z(), quat.w());
            
            if (pos.y() < -20) {
              physicsWorld.removeRigidBody(body);
              scene.remove(mesh);
              rigidBodies.splice(i, 1);
              i--;
            }
          }
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(clock.getDelta(), 0.1);
        
        updatePhysics(dt);
        
        if (vectorFieldEnabled && frameCount % 10 === 0) {
          renderVectorField();
        }
        
        frameCount++;
        const now = Date.now();
        if (now - lastFps > 1000) {
          document.getElementById('fps').textContent = frameCount;
          document.getElementById('physicsHz').textContent = Math.round(physicsSteps);
          frameCount = 0;
          physicsSteps = 0;
          lastFps = now;
        }
        
        document.getElementById('bodyCount').textContent = rigidBodies.length;
        document.getElementById('slipCount').textContent = totalSlipPoints;
        document.getElementById('impactCount').textContent = totalImpacts;
        document.getElementById('vectorCount').textContent = activeVectorCells;
        
        activeVectorCells = 0;
        
        controls.update();
        renderer.render(scene, camera);
      }

      // Initial spawn
      function initSpawn() {
        for (let i = 0; i < 3; i++) createShape('box');
        for (let i = 0; i < 2; i++) createShape('sphere');
      }
      
      initSpawn();
      animate();
    });
  </script>
</body>
</html>