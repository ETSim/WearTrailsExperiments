<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ammo.js Physics - Dynamic Paint (UV Trails + OBB Hull + Deferred Decals)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: linear-gradient(180deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; color: #fff; overflow: hidden; }
    #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; z-index: 1000; }
    #ui { position: fixed; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 12px; z-index: 100; max-width: 320px; }
    .ui-group { background: rgba(0,0,0,0.8); backdrop-filter: blur(10px); border-radius: 12px; padding: 14px; border: 1px solid rgba(255,255,255,0.1); }
    .ui-title { font-size: 11px; font-weight: bold; margin-bottom: 10px; color: #00ff88; text-transform: uppercase; letter-spacing: 1.5px; }
    button { width: 100%; padding: 10px; border: 0; border-radius: 8px; background: linear-gradient(135deg, #00ff88 0%, #00ccff 100%); color: #000; cursor: pointer; font-weight: 600; transition: all 0.3s; margin-bottom: 6px; font-size: 13px; }
    button:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4); }
    button.secondary { background: rgba(255,255,255,0.1); color: #fff; }
    button.secondary:hover { background: rgba(255,255,255,0.2); }
    button.active { background: linear-gradient(135deg, #ff0055 0%, #ff9a00 100%); color: #fff; }
    .slider-container { margin: 10px 0; }
    .slider-label { font-size: 11px; margin-bottom: 6px; display: flex; justify-content: space-between; color: #00ff88; }
    input[type="range"] { width: 100%; height: 6px; border-radius: 3px; background: rgba(0,255,136,0.2); outline: none; -webkit-appearance: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #00ff88; cursor: pointer; box-shadow: 0 0 10px rgba(0,255,136,0.5); }
    input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #00ff88; cursor: pointer; border: none; box-shadow: 0 0 10px rgba(0,255,136,0.5); }
    #info { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 16px; border-radius: 12px; font-size: 12px; backdrop-filter: blur(10px); max-width: 560px; border: 1px solid rgba(0,255,136,0.2); }
    #stats { position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.8); padding: 16px; border-radius: 12px; font-size: 12px; backdrop-filter: blur(10px); border: 1px solid rgba(0,255,136,0.2); min-width: 200px; }
    .stat-item { display: flex; justify-content: space-between; margin: 6px 0; }
    .stat-label { color: #00ff88; }
    .stat-value { font-weight: bold; color: #00ccff; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="loading">Loading Physics Engine...</div>

  <div id="ui" style="display:none;">
    <div class="ui-group">
      <div class="ui-title">üéØ Drop Objects</div>
      <button id="dropSphere">Sphere</button>
      <button id="dropBox">Box</button>
      <button id="dropCylinder">Cylinder</button>
      <button id="dropCone">Cone</button>
      <button id="dropTorus">Torus</button>
      <button id="dropCompound">Compound</button>
    </div>

    <div class="ui-group">
      <div class="ui-title">‚öôÔ∏è Physics</div>
      <div class="slider-container"><div class="slider-label"><span>Restitution</span><span id="restitutionValue">0.3</span></div><input type="range" id="restitutionSlider" min="0" max="100" value="30"></div>
      <div class="slider-container"><div class="slider-label"><span>Friction</span><span id="frictionValue">0.5</span></div><input type="range" id="frictionSlider" min="0" max="100" value="50"></div>
      <div class="slider-container"><div class="slider-label"><span>Gravity</span><span id="gravityValue">9.8</span></div><input type="range" id="gravitySlider" min="0" max="300" value="98"></div>
    </div>

    <div class="ui-group">
      <div class="ui-title">üñåÔ∏è Dynamic Paint</div>
      <button id="toggleTrail" class="active">Continuous Trails: ON</button>
      <button id="toggleHull" class="active">Hull Patches: ON</button>
            <button id="toggleVector" class="active">Vector Field: ON</button>
<button id="toggleEco" class="active">Perf Mode: Economy</button>
      <div class="slider-container"><div class="slider-label"><span>Trail Base Step (m)</span><span id="trailStepValue">0.05</span></div><input type="range" id="trailStep" min="1" max="25" value="5"></div>
      <div class="slider-container"><div class="slider-label"><span>Manifold Window (ms)</span><span id="manifoldMsValue">90</span></div><input type="range" id="manifoldMs" min="20" max="300" value="90"></div>
      <div class="slider-container"><div class="slider-label"><span>Slip Gain</span><span id="slipGainValue">1.0√ó</span></div><input type="range" id="slipGain" min="5" max="300" value="100"></div>
      <div class="slider-container"><div class="slider-label"><span>Patch Thickness √ó</span><span id="thickMulValue">1.0√ó</span></div><input type="range" id="thickMul" min="50" max="300" value="100"></div>
      <button id="clearDecals" class="secondary">Clear Paint</button>
      <button id="reset" class="secondary">Reset All</button>
      <div style="font-size:11px;opacity:.85;margin-top:6px;line-height:1.35;">Hold <b>Ctrl</b> + LMB to <b>grab &amp; drag</b> objects (Q/E height). Camera is locked while Ctrl is held.</div>
    </div>
  </div>

  <div id="info" style="display:none;">
    ‚ö° <b>Slip√óImpulse Dynamic Paint</b><br>
    ‚Ä¢ Trails and patches paint to a ground UV canvas; other surfaces use deferred decals.<br>
    ‚Ä¢ OBB hull patch (rotating calipers) = single tight decal per manifold.
  </div>

  <div id="stats" style="display:none;">
    <div class="stat-item"><span class="stat-label">Bodies:</span><span class="stat-value" id="bodyCount">0</span></div>
    <div class="stat-item"><span class="stat-label">Contacts:</span><span class="stat-value" id="contactCount">0</span></div>
    <div class="stat-item"><span class="stat-label">Paint:</span><span class="stat-value" id="decalCount">0</span></div>
    <div class="stat-item"><span class="stat-label">FPS:</span><span class="stat-value" id="fps">60</span></div>
  </div>

  <script src="https://cdn.jsdelivr.net/gh/kripken/ammo.js@main/builds/ammo.js"></script>
  <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';

    Ammo().then(function(Ammo) {
      let continuousPaint = true, hullPatch = true, economy = true;
      document.getElementById('loading').style.display = 'none';
      document.getElementById('ui').style.display = 'flex';
      document.getElementById('info').style.display = 'block';
      document.getElementById('stats').style.display = 'block';

      // Physics
      const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
      const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
      const overlappingPairCache = new Ammo.btDbvtBroadphase();
      const solver = new Ammo.btSequentialImpulseConstraintSolver();
      const physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
      physicsWorld.setGravity(new Ammo.btVector3(0, -9.8, 0));

      // Three
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x16213e, 20, 80);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(15, 12, 15);
      camera.lookAt(0, 0, 0);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI*0.49;
      controls.minDistance = 5;
      controls.maxDistance = 50;

      scene.add(new THREE.AmbientLight(0x404040, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
      dirLight.position.set(10,20,10);
      dirLight.castShadow = true;
      dirLight.shadow.camera.near=0.1; dirLight.shadow.camera.far=60;
      dirLight.shadow.camera.left=-25; dirLight.shadow.camera.right=25;
      dirLight.shadow.camera.top=25; dirLight.shadow.camera.bottom=-25;
      dirLight.shadow.mapSize.set(2048,2048);
      scene.add(dirLight);

      const pointLight1 = new THREE.PointLight(0x00ff88, 0.5, 40); pointLight1.position.set(-15,15,-15); scene.add(pointLight1);
      const pointLight2 = new THREE.PointLight(0x00ccff, 0.5, 40); pointLight2.position.set(15,15,15); scene.add(pointLight2);

      const colors = [0x00ff88,0x00ccff,0xff0055,0xffaa00,0xff00ff,0x88ff00,0x0088ff,0xff8800,0x8800ff,0xffff00];
      let physicsParams = { restitution: 0.3, friction: 0.5 };

      const rigidBodies = [];
      const tmpTrans = new Ammo.btTransform();
      const decalsGroup = new THREE.Group(); scene.add(decalsGroup);
      let totalContacts = 0;

      // Trail & patch params
      let MIN_TRAIL_STEP = 0.05, SLIP_GAIN = 1.0;
      let MANIFOLD_WINDOW_MS = 90, THICKNESS_MUL = 1.0;
      const TRAIL_MAX_TIME_STEP = 28; // ms cap between stamps

      // Ground
      const groundSize = 50;
      const groundGeo = new THREE.BoxGeometry(groundSize, 2, groundSize);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2e, roughness: 0.9, metalness: 0.0 });
      const groundMesh = new THREE.Mesh(groundGeo, groundMat);
      groundMesh.position.y = -1;
      groundMesh.receiveShadow = true;
      scene.add(groundMesh);

      const grid = new THREE.GridHelper(groundSize, 50, 0x00ff88, 0x003344);
      grid.position.y = 0.005; scene.add(grid);

      // UV paint layer on ground (XZ plane)
      const PAINT_RES = 1024;
      const paintCanvas = document.createElement('canvas'); paintCanvas.width = PAINT_RES; paintCanvas.height = PAINT_RES;
      const paintCtx = paintCanvas.getContext('2d');
      paintCtx.clearRect(0,0,PAINT_RES,PAINT_RES);
      const paintTex = new THREE.CanvasTexture(paintCanvas);
      paintTex.flipY = true;
      paintTex.wrapS = paintTex.wrapT = THREE.ClampToEdgeWrapping; paintTex.needsUpdate = true;
      const paintPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(groundSize, groundSize),
        new THREE.MeshBasicMaterial({ map: paintTex, transparent: true, depthWrite: false })
      );
      paintPlane.rotation.x = -Math.PI/2;
      paintPlane.position.y = 0.011;
      scene.add(paintPlane);

      // Ammo ground body
      const groundShape = new Ammo.btBoxShape(new Ammo.btVector3(groundSize/2, 1, groundSize/2));
      const groundTransform = new Ammo.btTransform(); groundTransform.setIdentity(); groundTransform.setOrigin(new Ammo.btVector3(0,-1,0));
      const groundMotionState = new Ammo.btDefaultMotionState(groundTransform);
      const groundRbInfo = new Ammo.btRigidBodyConstructionInfo(0, groundMotionState, groundShape, new Ammo.btVector3(0,0,0));
      groundRbInfo.set_m_restitution(0.3); groundRbInfo.set_m_friction(0.5);
      const groundBody = new Ammo.btRigidBody(groundRbInfo); physicsWorld.addRigidBody(groundBody);
      groundMesh.userData.physicsBody = groundBody;

      // Rigid body factory
      function createRigidBody(mesh, shape, mass, pos, quat) {
        const transform = new Ammo.btTransform(); transform.setIdentity(); transform.setOrigin(new Ammo.btVector3(pos.x,pos.y,pos.z)); transform.setRotation(new Ammo.btQuaternion(quat.x,quat.y,quat.z,quat.w));
        const motionState = new Ammo.btDefaultMotionState(transform);
        const localInertia = new Ammo.btVector3(0,0,0); shape.calculateLocalInertia(mass, localInertia);
        const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
        rbInfo.set_m_restitution(physicsParams.restitution); rbInfo.set_m_friction(physicsParams.friction);
        const body = new Ammo.btRigidBody(rbInfo); body.setActivationState(4);
        mesh.userData.physicsBody = body; mesh.userData.collided = false;
        scene.add(mesh); physicsWorld.addRigidBody(body); rigidBodies.push(mesh);
        return body;
      }

      function createShape(type) {
        const pos = new THREE.Vector3((Math.random()-0.5)*10, 10+Math.random()*10, (Math.random()-0.5)*10);
        const quat = new THREE.Quaternion(); const mass = 1; const color = colors[Math.floor(Math.random()*colors.length)];
        let mesh, shape;
        if (type==='sphere') { const r=0.5+Math.random()*0.5; mesh=new THREE.Mesh(new THREE.SphereGeometry(r,32,16), new THREE.MeshStandardMaterial({ color, roughness:0.4, metalness:0.2 })); shape=new Ammo.btSphereShape(r); }
        else if (type==='box') { const s=0.5+Math.random()*0.5; mesh=new THREE.Mesh(new THREE.BoxGeometry(s*2,s*2,s*2), new THREE.MeshStandardMaterial({ color, roughness:0.4, metalness:0.2 })); shape=new Ammo.btBoxShape(new Ammo.btVector3(s,s,s)); }
        else if (type==='cylinder') { const r=0.5+Math.random()*0.3, h=1+Math.random()*0.5; mesh=new THREE.Mesh(new THREE.CylinderGeometry(r,r,h,24), new THREE.MeshStandardMaterial({ color, roughness:0.4, metalness:0.2 })); shape=new Ammo.btCylinderShape(new Ammo.btVector3(r,h/2,r)); }
        else if (type==='cone') { const r=0.5+Math.random()*0.3, h=1+Math.random()*0.5; mesh=new THREE.Mesh(new THREE.ConeGeometry(r,h,24), new THREE.MeshStandardMaterial({ color, roughness:0.4, metalness:0.2 })); shape=new Ammo.btConeShape(r,h); }
        else if (type==='torus') { const g=new THREE.TorusGeometry(0.6,0.25,16,28); mesh=new THREE.Mesh(g, new THREE.MeshStandardMaterial({ color, roughness:0.4, metalness:0.2 })); const hull=new Ammo.btConvexHullShape(); const v=g.attributes.position.array; for(let i=0;i<v.length;i+=3){ hull.addPoint(new Ammo.btVector3(v[i],v[i+1],v[i+2]), true);} shape=hull; }
        else if (type==='compound') { const comp=new Ammo.btCompoundShape(); const group=new THREE.Group(); for(let i=0;i<3;i++){ const t=new Ammo.btTransform(); t.setIdentity(); const ox=(Math.random()-0.5)*1, oy=(Math.random()-0.5)*1, oz=(Math.random()-0.5)*1; t.setOrigin(new Ammo.btVector3(ox,oy,oz)); const sub=new Ammo.btSphereShape(0.3); comp.addChildShape(t, sub); const m=new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshStandardMaterial({ color, roughness:0.4, metalness:0.2 })); m.position.set(ox,oy,oz); group.add(m);} mesh=group; shape=comp; }
        else return;
        mesh.castShadow = true; mesh.receiveShadow = true; mesh.userData.color = color;
        const body = createRigidBody(mesh, shape, mass, pos, quat);
        const lv = new Ammo.btVector3((Math.random()-0.5)*5,0,(Math.random()-0.5)*5); body.setLinearVelocity(lv);
        const av = new Ammo.btVector3((Math.random()-0.5)*5,(Math.random()-0.5)*5,(Math.random()-0.5)*5); body.setAngularVelocity(av);
      }

      // Deferred decals to avoid frame spikes
      const DECAL_BUDGET_PER_FRAME = 6;
      const deferredDecalQueue = []; // items: {mesh, geoParams:{pos,rot,size}, mat}

      function makeBlobTexture(color){
        const c = new THREE.Color(color);
        const cvs = document.createElement('canvas'); cvs.width = cvs.height = 256; const ctx = cvs.getContext('2d');
        const g = ctx.createRadialGradient(128,128,0,128,128,110);
        g.addColorStop(0,`rgba(${(c.r*255)|0}, ${(c.g*255)|0}, ${(c.b*255)|0}, 0.9)`);
        g.addColorStop(0.5,`rgba(${(c.r*255)|0}, ${(c.g*255)|0}, ${(c.b*255)|0}, 0.6)`);
        g.addColorStop(1,`rgba(${(c.r*255)|0}, ${(c.g*255)|0}, ${(c.b*255)|0}, 0)`);
        ctx.fillStyle=g; ctx.fillRect(0,0,256,256);
        return new THREE.CanvasTexture(cvs);
      }

      function createDecal(point, normal, sizeVec3, color, opacity, targetMesh){
        if (targetMesh === groundMesh) { // UV canvas path
          drawPaintToGround(point, sizeVec3.x, opacity, color);
          return;
        }
        const tex = makeBlobTexture(color); tex.needsUpdate = true;
        const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, depthWrite: false, polygonOffset: true, polygonOffsetFactor: -4, opacity });

        const m4 = new THREE.Matrix4();
        const up = Math.abs(normal.y) > 0.9 ? new THREE.Vector3(1,0,0) : new THREE.Vector3(0,1,0);
        const look = point.clone().add(normal);
        m4.lookAt(point, look, up);
        const q = new THREE.Quaternion().setFromRotationMatrix(m4);
        const euler = new THREE.Euler().setFromQuaternion(q);

        deferredDecalQueue.push({
          mesh: targetMesh || groundMesh,
          geoParams: { pos: point.clone(), rot: euler.clone(), size: sizeVec3.clone() },
          mat
        });
      }

      // Ground UV helpers
      function worldToUVOnGround(p){
		  const u = THREE.MathUtils.clamp((p.x + groundSize/2)/groundSize, 0, 1);
		  const v = THREE.MathUtils.clamp((p.z + groundSize/2)/groundSize, 0, 1);
		  return {u, v};
		}
      function drawPaintToGround(worldPoint, radiusMeters, opacity, color){
        const uv = worldToUVOnGround(worldPoint);
        const px = uv.u * PAINT_RES, py = uv.v * PAINT_RES;
        const rpx = Math.max(2, (radiusMeters / groundSize) * PAINT_RES * 1.4);
        const c = new THREE.Color(color);
        const g = paintCtx.createRadialGradient(px,py,0,px,py,rpx);
        g.addColorStop(0, `rgba(${(c.r*255)|0},${(c.g*255)|0},${(c.b*255)|0},${Math.min(1,opacity)})`);
        g.addColorStop(1, `rgba(${(c.r*255)|0},${(c.g*255)|0},${(c.b*255)|0},0)`);
        paintCtx.globalCompositeOperation = 'lighter';
        paintCtx.fillStyle = g;
        paintCtx.beginPath(); paintCtx.arc(px,py,rpx,0,Math.PI*2); paintCtx.fill();
        paintTex.needsUpdate = true;
      }
      function drawVectorStreakToGround(p0, p1, color, alpha){
        const uv0 = worldToUVOnGround(p0), uv1 = worldToUVOnGround(p1);
        const x0 = uv0.u * PAINT_RES, y0 = uv0.v * PAINT_RES;
        const x1 = uv1.u * PAINT_RES, y1 = uv1.v * PAINT_RES;
        const c = new THREE.Color(color);
        paintCtx.globalCompositeOperation = 'lighter';
        paintCtx.lineWidth = 2.0;
        paintCtx.strokeStyle = `rgba(${(c.r*255|0)},${(c.g*255|0)},${(c.b*255|0)},${alpha})`;
        paintCtx.beginPath(); paintCtx.moveTo(x0,y0); paintCtx.lineTo(x1,y1); paintCtx.stroke();
        // small arrow head
        const dx=x1-x0, dy=y1-y0, L=Math.hypot(dx,dy)||1;
        const ux=dx/L, uy=dy/L;
        paintCtx.beginPath();
        paintCtx.moveTo(x1,y1);
        paintCtx.lineTo(x1-ux*6 - uy*3, y1-uy*6 + ux*3);
        paintCtx.moveTo(x1,y1);
        paintCtx.lineTo(x1-ux*6 + uy*3, y1-uy*6 - ux*3);
        paintCtx.stroke();
        paintTex.needsUpdate = true;
      }

      // Slip computation
      function computeSlip(body, bodyMesh, contactPoint, normal){
        const v = body.getLinearVelocity(); const vx=v.x(), vy=v.y(), vz=v.z();
        body.getMotionState().getWorldTransform(tmpTrans); const pos = tmpTrans.getOrigin();
        const r = new THREE.Vector3(contactPoint.x - pos.x(), contactPoint.y - pos.y(), contactPoint.z - pos.z());
        const w = body.getAngularVelocity(); const wx=w.x(), wy=w.y(), wz=w.z();
        const vrx = wy*r.z - wz*r.y; const vry = wz*r.x - wx*r.z; const vrz = wx*r.y - wy*r.x;
        const dotL = vx*normal.x + vy*normal.y + vz*normal.z; const vtx=vx - dotL*normal.x, vty=vy - dotL*normal.y, vtz=vz - dotL*normal.z;
        const dotR = vrx*normal.x + vry*normal.y + vrz*normal.z; const vrollx=vrx - dotR*normal.x, vrolly=vry - dotR*normal.y, vrollz=vrz - dotR*normal.z;
        const vt = Math.hypot(vtx, vty, vtz); const vroll = Math.hypot(vrollx, vrolly, vrollz);
        const sx = vtx - vrollx, sy = vty - vrolly, sz = vtz - vrollz; const slipSpeed = Math.hypot(sx, sy, sz);
        const slipRatio = slipSpeed / Math.max(0.1, vt + vroll);
        return { slipRatio, vtPlanar: vt };
      }

      const trailState = new Map();
            let useVectorField = true;

      // --- Vector field accumulation (UV space) ---
      const FIELD_RES = 32; // grid resolution for vector-field overlay
      const _vf = new Float32Array(FIELD_RES * FIELD_RES * 3); // [vx, vy, w] per cell

      function _vfIndex(u, v){
        const i = Math.min(FIELD_RES-1, Math.max(0, Math.floor(u * FIELD_RES)));
        const j = Math.min(FIELD_RES-1, Math.max(0, Math.floor(v * FIELD_RES)));
        return {i, j, idx: (j*FIELD_RES + i)*3};
      }
      function accumVectorField(uv0, uv1, weight){
        const a = _vfIndex(uv1.u, uv1.v);
        const dvx = (uv1.u - uv0.u);
        const dvy = (uv1.v - uv0.v);
        _vf[a.idx]   += dvx * weight;
        _vf[a.idx+1] += dvy * weight;
        _vf[a.idx+2] += weight;
      }
      function drawFieldAtUV(uv0, uv1){
        const a = _vfIndex(uv1.u, uv1.v);
        const idx = a.idx;
        const w = _vf[idx+2];
        if (w <= 0) return;
        const vx = _vf[idx] / w, vy = _vf[idx+1] / w;
        const cx = ((a.i + 0.5) / FIELD_RES) * PAINT_RES;
        const cy = ((a.j + 0.5) / FIELD_RES) * PAINT_RES;
        const L = Math.hypot(vx, vy);
        if (L < 1e-5) return;
        const scale = Math.min(18, 4 + L * PAINT_RES * 0.35);
        const x1 = cx + (vx / L) * scale;
        const y1 = cy + (vy / L) * scale;
        paintCtx.globalCompositeOperation = 'lighter';
        paintCtx.lineWidth = 1.0;
        // speed -> hue map (fast = warm)
        const hue = Math.max(0, Math.min(240, 240 - L * 600));
        paintCtx.strokeStyle = `hsl(${hue}, 90%, 55%)`;
        paintCtx.beginPath(); paintCtx.moveTo(cx,cy); paintCtx.lineTo(x1,y1); paintCtx.stroke();
        // arrowhead
        const dx = x1-cx, dy = y1-cy, ll = Math.hypot(dx,dy) || 1, ux = dx/ll, uy = dy/ll;
        paintCtx.beginPath();
        paintCtx.moveTo(x1,y1);
        paintCtx.lineTo(x1-ux*5 - uy*3, y1-uy*5 + ux*3);
        paintCtx.moveTo(x1,y1);
        paintCtx.lineTo(x1-ux*5 + uy*3, y1-uy*5 - ux*3);
        paintCtx.stroke();
        paintTex.needsUpdate = true;
      }
      function clearVectorField(){
        _vf.fill(0);
      }

const manifoldBuckets = new Map();

      function stampTrailFromContact(dynamicBody, dynamicMesh, surfaceMesh, point, normal, normalImpulse){
        const s = computeSlip(dynamicBody, dynamicMesh, point, normal);
        const slipImpulse = s.slipRatio * Math.max(0, normalImpulse);
        const densityScale = 1 + SLIP_GAIN * slipImpulse * 0.05;
        const opacity = THREE.MathUtils.clamp(0.4 + SLIP_GAIN * slipImpulse * 0.15, 0.25, 1.0);
        const step = THREE.MathUtils.clamp(MIN_TRAIL_STEP / densityScale, 0.01, 0.2);

        const state = trailState.get(dynamicBody) || { lastPoint:null, lastTime:0, lastMesh:null };
        const P = new THREE.Vector3(point.x, point.y, point.z);
        const nowMs = performance.now();
        const needDist = (!state.lastPoint) || state.lastMesh !== surfaceMesh || state.lastPoint.distanceTo(P) >= step;
        const needTime = (nowMs - state.lastTime) >= TRAIL_MAX_TIME_STEP;

        if (needDist && needTime) {
          const N = new THREE.Vector3(normal.x, normal.y, normal.z);
          const radius = THREE.MathUtils.clamp(0.12 + s.vtPlanar*0.008 + slipImpulse*0.02, 0.08, 0.45);
          createDecal(P, N, new THREE.Vector3(radius, radius, 0.5), dynamicMesh.userData.color || 0x00ff88, opacity, surfaceMesh);

          if (surfaceMesh === groundMesh && state.lastPoint){            if (useVectorField && surfaceMesh === groundMesh && state.lastPoint){
              drawVectorStreakToGround(state.lastPoint.clone(), P, dynamicMesh.userData.color || 0x00ff88, 0.35);
              // accumulate and paint vector field arrow in the texture
              const uv0 = worldToUVOnGround(state.lastPoint);
              const uv1 = worldToUVOnGround(P);
              accumVectorField(uv0, uv1, 1.0);
              drawFieldAtUV(uv0, uv1);
            }
}

          state.lastPoint = P.clone(); state.lastTime = nowMs; state.lastMesh = surfaceMesh;
          trailState.set(dynamicBody, state);
          totalContacts++;
        }
      }

      // OBB hull patch with rotating calipers
      function paintHullSingleDecal(worldPts, normal, sourceMesh, surfaceMesh, penetration, color){
        const n = new THREE.Vector3(normal.x, normal.y, normal.z).normalize();
        const tmp = Math.abs(n.y) > 0.9 ? new THREE.Vector3(1,0,0) : new THREE.Vector3(0,1,0);
        const t1 = new THREE.Vector3().crossVectors(tmp, n).normalize();
        const t2 = new THREE.Vector3().crossVectors(n, t1).normalize();
        const base = worldPts[0];

        // project to 2D
        const pts2 = worldPts.map(p=>{
          const d = p.clone().sub(base);
          return {x: d.dot(t1), y: d.dot(t2)};
        });

        function hull2D(pts){
          if (pts.length<=3) return pts.slice();
          const s=pts.slice().sort((a,b)=> a.x===b.x? a.y-b.y : a.x-b.x);
          const cross=(o,a,b)=> (a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x);
          const lower=[];
          for(let i=0;i<s.length;i++){ const p=s[i]; while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop(); lower.push(p); }
          const upper=[];
          for(let i=s.length-1;i>=0;i--){ const p=s[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop(); upper.push(p); }
          upper.pop(); lower.pop(); return lower.concat(upper);
        }
        const hull = hull2D(pts2);
        if (hull.length<3) return;

        function minAreaRect(h){
          let best = {area: Infinity, cx:0, cy:0, ux:1, uy:0, vx:0, vy:1, ex:0, ey:0};
          for (let k=0;k<h.length;k++){
            const a=h[k], b=h[(k+1)%h.length];
            const ax=b.x-a.x, ay=b.y-a.y;
            const len=Math.hypot(ax,ay); if (len<1e-6) continue;
            const ux=ax/len, uy=ay/len;
            const vx=-uy, vy=ux;
            let minU=Infinity,maxU=-Infinity,minV=Infinity,maxV=-Infinity;
            for (let i=0;i<h.length;i++){
              const p=h[i]; const u = p.x*ux + p.y*uy; const v = p.x*vx + p.y*vy;
              if (u<minU) minU=u; if (u>maxU) maxU=u;
              if (v<minV) minV=v; if (v>maxV) maxV=v;
            }
            const ex = (maxU-minU)/2, ey=(maxV-minV)/2;
            const area = (ex*2)*(ey*2);
            if (area < best.area){
              const uc = (minU+maxU)/2, vc=(minV+maxV)/2;
              best = {area, cx:uc, cy:vc, ux, uy, vx, vy, ex, ey};
            }
          }
          return best;
        }
        const r = minAreaRect(hull);

        const center = base.clone()
          .add(t1.clone().multiplyScalar(r.cx))
          .add(t2.clone().multiplyScalar(r.cy));

        const dir2 = new THREE.Vector3().addScaledVector(t1, r.ux).addScaledVector(t2, r.uy).normalize();
        const bin2 = new THREE.Vector3().addScaledVector(t1, r.vx).addScaledVector(t2, r.vy).normalize();
        const m = new THREE.Matrix4().makeBasis(dir2, n, bin2);   // X=dir2, Y=normal, Z=bin2
        const q = new THREE.Quaternion().setFromRotationMatrix(m);
        const e = new THREE.Euler().setFromQuaternion(q);

        const width  = Math.max(0.05, r.ex*2)*1.03;
        const height = Math.max(0.05, r.ey*2)*1.03;
        const thickness = Math.max(0.02, penetration*THICKNESS_MUL + 0.02);

        // surface == ground? prefer UV fill rectangle for zero-geometry cost
        if (surfaceMesh === groundMesh){
          // draw rect in UV space (approx footprint)
          let minx=Infinity,maxx=-Infinity,minz=Infinity,maxz=-Infinity;
          for (let i=0;i<worldPts.length;i++){ const p=worldPts[i]; if(p.x<minx)minx=p.x; if(p.x>maxx)maxx=p.x; if(p.z<minz)minz=p.z; if(p.z>maxz)maxz=p.z; }
          const p1 = new THREE.Vector3(minx,0,minz), p2 = new THREE.Vector3(maxx,0,maxz);
          const uv1 = worldToUVOnGround(p1), uv2 = worldToUVOnGround(p2);
          const x = Math.min(uv1.u, uv2.u)*PAINT_RES, y = Math.min(uv1.v, uv2.v)*PAINT_RES;
          const w = Math.abs(uv2.u-uv1.u)*PAINT_RES, h = Math.abs(uv2.v-uv1.v)*PAINT_RES;
          const c = new THREE.Color(color);
          paintCtx.globalCompositeOperation = 'lighter';
          paintCtx.fillStyle = `rgba(${(c.r*255)|0},${(c.g*255)|0},${(c.b*255)|0},0.85)`;
          paintCtx.fillRect(x, y, Math.max(2,w), Math.max(2,h));
          paintTex.needsUpdate = true;
          return;
        }

        deferredDecalQueue.push({
          mesh: surfaceMesh,
          geoParams: { pos: center, rot: e, size: new THREE.Vector3(width, height, thickness) },
          mat: new THREE.MeshBasicMaterial({ map: makeBlobTexture(color), transparent:true, depthWrite:false, polygonOffset:true, polygonOffsetFactor:-4, opacity:0.85 })
        });
      }

      // Contact processing
      function processContacts() {
        const numManifolds = dispatcher.getNumManifolds();
        const now = performance.now();
        for (let i=0; i<numManifolds; i++) {
          const manifold = dispatcher.getManifoldByIndexInternal(i);
          const body0 = Ammo.castObject(manifold.getBody0(), Ammo.btRigidBody);
          const body1 = Ammo.castObject(manifold.getBody1(), Ammo.btRigidBody);
          const numContacts = manifold.getNumContacts();

          let mesh0=null, mesh1=null;
          for (let rbi=0; rbi<rigidBodies.length; rbi++){ const rb = rigidBodies[rbi]; const b = rb.userData.physicsBody; if (b===body0) mesh0=rb; if (b===body1) mesh1=rb; }
          if (groundMesh.userData.physicsBody === body0) mesh0 = groundMesh;
          if (groundMesh.userData.physicsBody === body1) mesh1 = groundMesh;
          if (!mesh0 || !mesh1) continue;

          for (let j=0; j<numContacts; j++) {
            const cp = manifold.getContactPoint(j);
            const distance = cp.getDistance();
            if (distance < 0.01) {
              const ptA = cp.getPositionWorldOnA();
              const ptB = cp.getPositionWorldOnB();
              const nB = cp.get_m_normalWorldOnB();
              const impulse = cp.getAppliedImpulse();

              const paintOn1 = (mesh0!==groundMesh); // dynamic on A ‚áí paint on B
              const point = paintOn1 ? new THREE.Vector3(ptB.x(), ptB.y(), ptB.z()) : new THREE.Vector3(ptA.x(), ptA.y(), ptA.z());
              const normal = new THREE.Vector3(nB.x(), nB.y(), nB.z());
              const dynamicMesh = paintOn1 ? mesh0 : mesh1;
              const surfaceMesh = paintOn1 ? mesh1 : mesh0;
              const dynamicBody = paintOn1 ? body0 : body1;

              if (continuousPaint) stampTrailFromContact(dynamicBody, dynamicMesh, surfaceMesh, {x:point.x, y:point.y, z:point.z}, {x:normal.x, y:normal.y, z:normal.z}, impulse);

              if (hullPatch) {
                const dynPtr = Ammo.getPointer(dynamicBody);
                const surfPtr = Ammo.getPointer(surfaceMesh.userData.physicsBody);
                const key = dynPtr + '|' + surfPtr;
                let bucket = manifoldBuckets.get(key);
                if (!bucket) { bucket = { t0: now, pts: [], normal: paintOn1? normal.clone() : normal.clone().negate(), dynamicMesh, surfaceMesh, maxPen: 0 }; manifoldBuckets.set(key, bucket); }
                bucket.pts.push(point.clone());
                bucket.normal.lerp(paintOn1? normal : normal.clone().negate(), 0.5).normalize();
                if (distance < 0) bucket.maxPen = Math.max(bucket.maxPen, -distance);
              }
            }
          }
        }
        const now2 = performance.now();
        for (const [key, bucket] of manifoldBuckets) {
          if (now2 - bucket.t0 >= MANIFOLD_WINDOW_MS) {
            if (bucket.pts.length >= 3) {
              paintHullSingleDecal(bucket.pts, bucket.normal, bucket.dynamicMesh, bucket.surfaceMesh, bucket.maxPen, bucket.dynamicMesh.userData.color || 0x00ff88);
              totalContacts++;
            }
            manifoldBuckets.delete(key);
          }
        }
      }

      // Ctrl-drag input with camera lock while Ctrl
      const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
      let dragging = false, dragBody=null, dragMesh=null, dragLocal=null, dragHeight=0;
      const DRAG_STIFF=140, DRAG_DAMP=14;
      let ctrlDown = false;
      function setControlsEnabled() { controls.enabled = !(ctrlDown || dragging); }

      function screenToWorldOnPlane(clientX, clientY, y){
        mouse.x=(clientX/window.innerWidth)*2-1; mouse.y=-(clientY/window.innerHeight)*2+1; raycaster.setFromCamera(mouse, camera);
        const plane = new THREE.Plane(new THREE.Vector3(0,1,0), -y); const pt = new THREE.Vector3(); raycaster.ray.intersectPlane(plane, pt); return pt;
      }
      function pointerDown(e){
        if (!e.ctrlKey) return;
        e.preventDefault();
        mouse.x=(e.clientX/window.innerWidth)*2-1; mouse.y=-(e.clientY/window.innerHeight)*2+1; raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(rigidBodies, true);
        if (intersects.length){
          let obj=intersects[0].object; while(obj && !obj.userData.physicsBody && obj.parent) obj=obj.parent; if (!obj) return;
          dragMesh=obj; dragBody=obj.userData.physicsBody; if (!dragBody) return;
          dragging=true; setControlsEnabled(); dragBody.activate();
          const hit = intersects[0].point.clone(); dragLocal = hit.clone().applyMatrix4(new THREE.Matrix4().copy(obj.matrixWorld).invert()); dragHeight = hit.y;
        }
      }
      function pointerMove(e){
        if (!dragging || !dragBody) return;
        const worldGrab = dragLocal.clone().applyMatrix4(dragMesh.matrixWorld);
        const target = screenToWorldOnPlane(e.clientX, e.clientY, dragHeight);
        const err = target.sub(worldGrab);
        const force = err.multiplyScalar(DRAG_STIFF);
        const f = new Ammo.btVector3(force.x, force.y, force.z); dragBody.applyCentralForce(f); Ammo.destroy(f);
        const lv = dragBody.getLinearVelocity(); const damp = new Ammo.btVector3(-DRAG_DAMP*lv.x(), -DRAG_DAMP*lv.y(), -DRAG_DAMP*lv.z()); dragBody.applyCentralForce(damp); Ammo.destroy(damp);
      }
      function pointerUp(){ dragging=false; dragBody=null; dragMesh=null; dragLocal=null; setControlsEnabled(); }

      window.addEventListener('pointerdown', pointerDown, {passive:false});
      window.addEventListener('pointermove', pointerMove);
      window.addEventListener('pointerup', pointerUp);

      window.addEventListener('keydown', (e)=>{
        if (e.key==='Control'){ ctrlDown = true; setControlsEnabled(); e.preventDefault(); }
        if (!dragging) return;
        if (e.key==='q' || e.key==='Q') dragHeight -= 0.1;
        if (e.key==='e' || e.key==='E') dragHeight += 0.1;
      });
      window.addEventListener('keyup', (e)=>{ if (e.key==='Control'){ ctrlDown = false; setControlsEnabled(); } });

      // Per-frame
      const clock = new THREE.Clock(); let frameCount=0; let lastFps=0;
      function updatePhysics(dt){
        physicsWorld.stepSimulation(dt, 10);
        for (let i=0;i<rigidBodies.length;i++){
          const mesh=rigidBodies[i]; const body=mesh.userData.physicsBody;
          if (body && body.getMotionState){
            body.getMotionState().getWorldTransform(tmpTrans);
            const pos=tmpTrans.getOrigin(); const quat=tmpTrans.getRotation();
            mesh.position.set(pos.x(),pos.y(),pos.z()); mesh.quaternion.set(quat.x(),quat.y(),quat.z(),quat.w());
            if (pos.y() < -20){ physicsWorld.removeRigidBody(body); scene.remove(mesh); rigidBodies.splice(i,1); i--; trailState.delete(body); }
          }
        }
        processContacts();
      }

      function animate(){
        requestAnimationFrame(animate);
        const dt=clock.getDelta();
        updatePhysics(dt);

        // Build a few deferred decals this frame
        let built = 0;
        while (built < DECAL_BUDGET_PER_FRAME && deferredDecalQueue.length){
          const item = deferredDecalQueue.shift();
          try {
            const geo = new DecalGeometry(item.mesh, item.geoParams.pos, item.geoParams.rot, item.geoParams.size);
            const m = new THREE.Mesh(geo, item.mat);
            decalsGroup.add(m);
          } catch(_) {}
          built++;
        }

        frameCount++; const now=Date.now();
        if (now-lastFps>1000){ document.getElementById('fps').textContent=frameCount; frameCount=0; lastFps=now; }
        document.getElementById('bodyCount').textContent=rigidBodies.length;
        document.getElementById('contactCount').textContent=totalContacts;
        document.getElementById('decalCount').textContent=decalsGroup.children.length;

        controls.update(); renderer.render(scene, camera);
      }

      // UI buttons
      document.getElementById('dropSphere').addEventListener('click', ()=>createShape('sphere'));
      document.getElementById('dropBox').addEventListener('click', ()=>createShape('box'));
      document.getElementById('dropCylinder').addEventListener('click', ()=>createShape('cylinder'));
      document.getElementById('dropCone').addEventListener('click', ()=>createShape('cone'));
      document.getElementById('dropTorus').addEventListener('click', ()=>createShape('torus'));
      document.getElementById('dropCompound').addEventListener('click', ()=>createShape('compound'));

      document.getElementById('toggleTrail').addEventListener('click', (e)=>{ continuousPaint=!continuousPaint; e.target.classList.toggle('active', continuousPaint); e.target.textContent = `Continuous Trails: ${continuousPaint? 'ON':'OFF'}`; });
      document.getElementById('toggleHull').addEventListener('click', (e)=>{ hullPatch=!hullPatch; e.target.classList.toggle('active', hullPatch); e.target.textContent = `Hull Patches: ${hullPatch? 'ON':'OFF'}`; });
      document.getElementById('toggleEco').addEventListener('click', (e)=>{ economy=!economy; e.target.classList.toggle('active', economy); e.target.textContent = `Perf Mode: ${economy? 'Economy':'Rich'}`; });

      // Physics sliders live-update
      const restitutionSlider = document.getElementById('restitutionSlider');
      const frictionSlider = document.getElementById('frictionSlider');
      const gravitySlider = document.getElementById('gravitySlider');
      const restitutionValue = document.getElementById('restitutionValue');
      const frictionValue = document.getElementById('frictionValue');
      const gravityValue = document.getElementById('gravityValue');

      restitutionSlider.addEventListener('input', ()=>{ physicsParams.restitution = (+restitutionSlider.value)/100; restitutionValue.textContent = physicsParams.restitution.toFixed(2); for(const m of rigidBodies){ const b=m.userData.physicsBody; b.setRestitution(physicsParams.restitution);} groundBody.setRestitution(physicsParams.restitution); });
      frictionSlider.addEventListener('input', ()=>{ physicsParams.friction = (+frictionSlider.value)/100; frictionValue.textContent = physicsParams.friction.toFixed(2); for(const m of rigidBodies){ const b=m.userData.physicsBody; b.setFriction(physicsParams.friction);} groundBody.setFriction(physicsParams.friction); });
      gravitySlider.addEventListener('input', ()=>{ const g = (+gravitySlider.value)/10; gravityValue.textContent = g.toFixed(1); physicsWorld.setGravity(new Ammo.btVector3(0, -g, 0)); });

      // Paint sliders
      const trailStep = document.getElementById('trailStep'); const trailStepValue = document.getElementById('trailStepValue');
      const manifoldMs = document.getElementById('manifoldMs'); const manifoldMsValue = document.getElementById('manifoldMsValue');
      const slipGain = document.getElementById('slipGain'); const slipGainValue = document.getElementById('slipGainValue');
      const thickMul = document.getElementById('thickMul'); const thickMulValue = document.getElementById('thickMulValue');
      const stepToMeters = (v)=> (v/100)*0.24 + 0.01; const metersToStep = (m)=> Math.round(((m-0.01)/0.24)*100);
      trailStep.value = metersToStep(MIN_TRAIL_STEP); trailStepValue.textContent = MIN_TRAIL_STEP.toFixed(2);
      trailStep.addEventListener('input', (e)=>{ MIN_TRAIL_STEP = stepToMeters(+e.target.value); trailStepValue.textContent = MIN_TRAIL_STEP.toFixed(2); });
      manifoldMs.addEventListener('input', (e)=>{ MANIFOLD_WINDOW_MS = +e.target.value; manifoldMsValue.textContent = MANIFOLD_WINDOW_MS; });
      slipGain.addEventListener('input', (e)=>{ SLIP_GAIN = (+e.target.value)/100; slipGainValue.textContent = SLIP_GAIN.toFixed(1)+"√ó"; });
      thickMul.addEventListener('input', (e)=>{ THICKNESS_MUL = (+e.target.value)/100; thickMulValue.textContent = THICKNESS_MUL.toFixed(1)+"√ó"; });

      
      // Vector field toggle
      const toggleVectorBtn = document.getElementById('toggleVector');
      if (toggleVectorBtn){
        toggleVectorBtn.addEventListener('click', ()=>{
          useVectorField = !useVectorField;
          toggleVectorBtn.classList.toggle('active', useVectorField);
          toggleVectorBtn.textContent = useVectorField ? 'Vector Field: ON' : 'Vector Field: OFF';
        });
      }
document.getElementById('clearDecals').addEventListener('click', ()=>{
        for (let i=decalsGroup.children.length-1;i>=0;i--) decalsGroup.remove(decalsGroup.children[i]);
        paintCtx.clearRect(0,0,PAINT_RES,PAINT_RES); paintTex.needsUpdate = true; totalContacts = 0; clearVectorField();
      });
      document.getElementById('reset').addEventListener('click', ()=>{
        for (let i=rigidBodies.length-1;i>=0;i--){ const m=rigidBodies[i]; physicsWorld.removeRigidBody(m.userData.physicsBody); scene.remove(m); rigidBodies.pop(); }
        for (let i=decalsGroup.children.length-1;i>=0;i--) decalsGroup.remove(decalsGroup.children[i]);
        paintCtx.clearRect(0,0,PAINT_RES,PAINT_RES); paintTex.needsUpdate = true; totalContacts = 0; clearVectorField(); trailState.clear();
      });

      window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

      function initSpawn(){ for(let i=0;i<4;i++) createShape('box'); for(let i=0;i<3;i++) createShape('sphere'); }
      initSpawn();
      animate();
    });
  </script>
</body>
</html>