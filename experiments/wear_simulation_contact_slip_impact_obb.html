<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Precise Directional Wear Simulation with OBB Hull Patches</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: linear-gradient(180deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; color: #fff; overflow: hidden; }
    #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; z-index: 1000; }
    
    /* UI Panels */
    #ui-left { position: fixed; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 12px; z-index: 100; max-width: 340px; }
    #ui-right { position: fixed; top: 20px; right: 20px; display: flex; flex-direction: column; gap: 12px; z-index: 100; max-width: 340px; }
    
    .ui-group { background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); border-radius: 12px; padding: 14px; border: 1px solid rgba(255,255,255,0.1); }
    .ui-title { font-size: 11px; font-weight: bold; margin-bottom: 10px; color: #00ff88; text-transform: uppercase; letter-spacing: 1.5px; }
    button { width: 100%; padding: 10px; border: 0; border-radius: 8px; background: linear-gradient(135deg, #00ff88 0%, #00ccff 100%); color: #000; cursor: pointer; font-weight: 600; transition: all 0.3s; margin-bottom: 6px; font-size: 13px; }
    button:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4); }
    button.secondary { background: rgba(255,255,255,0.1); color: #fff; }
    button.secondary:hover { background: rgba(255,255,255,0.2); }
    button.active { background: linear-gradient(135deg, #ff0055 0%, #ff9a00 100%); color: #fff; }
    button.export { background: linear-gradient(135deg, #9333ea 0%, #4f46e5 100%); color: #fff; }
    .slider-container { margin: 10px 0; }
    .slider-label { font-size: 11px; margin-bottom: 6px; display: flex; justify-content: space-between; color: #00ff88; }
    input[type="range"] { width: 100%; height: 6px; border-radius: 3px; background: rgba(0,255,136,0.2); outline: none; -webkit-appearance: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #00ff88; cursor: pointer; box-shadow: 0 0 10px rgba(0,255,136,0.5); }
    input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #00ff88; cursor: pointer; border: none; box-shadow: 0 0 10px rgba(0,255,136,0.5); }
    
    #info { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.85); padding: 16px; border-radius: 12px; font-size: 12px; backdrop-filter: blur(10px); max-width: 400px; border: 1px solid rgba(0,255,136,0.2); }
    #stats { position: fixed; bottom: 20px; right: 20px; background: rgba(0,0,0,0.85); padding: 16px; border-radius: 12px; font-size: 12px; backdrop-filter: blur(10px); border: 1px solid rgba(0,255,136,0.2); min-width: 220px; }
    .stat-item { display: flex; justify-content: space-between; margin: 6px 0; }
    .stat-label { color: #00ff88; }
    .stat-value { font-weight: bold; color: #00ccff; }
    canvas { display: block; }
    
    .color-picker { 
      width: 100%; 
      height: 40px; 
      border: 2px solid rgba(0,255,136,0.3); 
      border-radius: 8px; 
      cursor: pointer; 
      margin-bottom: 8px;
    }
    
    .wear-indicator {
      display: flex; gap: 8px; margin-top: 8px;
      font-size: 10px; align-items: center;
    }
    .wear-dot {
      width: 12px; height: 12px; border-radius: 50%;
      display: inline-block;
    }
  </style>
</head>
<body>
  <div id="loading">Loading Physics Engine...</div>

  <!-- Left UI Panel -->
  <div id="ui-left" style="display:none;">
    <div class="ui-group">
      <div class="ui-title">üéØ Drop Objects</div>
      <button id="dropSphere">Sphere</button>
      <button id="dropBox">Box</button>
      <button id="dropCylinder">Cylinder</button>
      <button id="dropCone">Cone</button>
      <button id="dropTorus">Torus</button>
      <button id="dropCompound">Compound</button>
    </div>

    <div class="ui-group">
      <div class="ui-title">‚öôÔ∏è Physics</div>
      <div class="slider-container"><div class="slider-label"><span>Restitution</span><span id="restitutionValue">0.3</span></div><input type="range" id="restitutionSlider" min="0" max="100" value="30"></div>
      <div class="slider-container"><div class="slider-label"><span>Friction</span><span id="frictionValue">0.5</span></div><input type="range" id="frictionSlider" min="0" max="100" value="50"></div>
      <div class="slider-container"><div class="slider-label"><span>Gravity</span><span id="gravityValue">9.8</span></div><input type="range" id="gravitySlider" min="0" max="300" value="98"></div>
    </div>

    <div class="ui-group">
      <div class="ui-title">üé® Paint Color</div>
      <input type="color" id="paintColor" class="color-picker" value="#00ff88">
      <button id="toggleSameColor" class="active">Same Color Mode: ON</button>
    </div>
  </div>

  <!-- Right UI Panel -->
  <div id="ui-right" style="display:none;">
    <div class="ui-group">
      <div class="ui-title">üñåÔ∏è Wear Simulation</div>
      <button id="togglePrecise" class="active">Precise Mode: ON</button>
      <button id="togglePerformance" class="active">Performance: ECO</button>
      <button id="toggleGaussian" class="active">Gaussian Falloff: ON</button>
      <button id="toggleHullPatches" class="active">Hull Patches: ON</button>
      <button id="toggleDirectional" class="active">Directional Wear: ON</button>
      
      <div class="wear-indicator">
        <span>Wear Layers:</span>
        <span class="wear-dot" style="background: #00ff88;" title="Slip wear"></span>
        <span>Slip</span>
        <span class="wear-dot" style="background: #ff0055;" title="Impact wear"></span>
        <span>Impact</span>
        <span class="wear-dot" style="background: #00ccff;" title="Directional"></span>
        <span>Direction</span>
      </div>
      
      <div class="slider-container"><div class="slider-label"><span>Slip Threshold</span><span id="slipThresholdValue">0.05</span></div><input type="range" id="slipThreshold" min="1" max="100" value="5"></div>
      <div class="slider-container"><div class="slider-label"><span>Wear Intensity</span><span id="wearIntensityValue">0.7</span></div><input type="range" id="wearIntensity" min="10" max="100" value="70"></div>
      <div class="slider-container"><div class="slider-label"><span>Hull Sensitivity</span><span id="hullSensValue">0.8</span></div><input type="range" id="hullSens" min="10" max="100" value="80"></div>
      <div class="slider-container"><div class="slider-label"><span>Sample Rate (Hz)</span><span id="sampleRateValue">120</span></div><input type="range" id="sampleRate" min="30" max="240" value="120"></div>
      
      <button id="clearPaint" class="secondary">Clear All Layers</button>
      <button id="reset" class="secondary">Reset Scene</button>
    </div>

    <div class="ui-group">
      <div class="ui-title">üíæ Export</div>
      <button id="exportWear" class="export">Export Wear Map</button>
      <button id="exportDirectional" class="export">Export Directional</button>
      <button id="exportComposite" class="export">Export Composite</button>
      <button id="exportData" class="export">Export Scene Data</button>
    </div>
  </div>

  <div id="info" style="display:none;">
    ‚ö° <b>Directional Wear Simulation</b><br>
    ‚Ä¢ <b>Slip Wear:</b> Continuous wear from sliding friction<br>
    ‚Ä¢ <b>Impact Zones:</b> High-pressure contact patches<br>
    ‚Ä¢ <b>Hull Patches:</b> Face-to-face contact areas<br>
    ‚Ä¢ <b>Directional Field:</b> Velocity-based wear patterns<br>
    ‚Ä¢ <b>Ctrl + Drag:</b> Grab and move objects (Q/E for height)
  </div>

  <div id="stats" style="display:none;">
    <div class="stat-item"><span class="stat-label">Bodies:</span><span class="stat-value" id="bodyCount">0</span></div>
    <div class="stat-item"><span class="stat-label">Contacts:</span><span class="stat-value" id="contactCount">0</span></div>
    <div class="stat-item"><span class="stat-label">Wear Points:</span><span class="stat-value" id="wearCount">0</span></div>
    <div class="stat-item"><span class="stat-label">Hull Patches:</span><span class="stat-value" id="hullCount">0</span></div>
    <div class="stat-item"><span class="stat-label">FPS:</span><span class="stat-value" id="fps">60</span></div>
    <div class="stat-item"><span class="stat-label">Physics Hz:</span><span class="stat-value" id="physicsHz">0</span></div>
  </div>

  <script src="https://cdn.jsdelivr.net/gh/kripken/ammo.js@main/builds/ammo.js"></script>
  <script type="importmap">{ 
    "imports": { 
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js", 
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" 
    } 
  }</script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    Ammo().then(function(Ammo) {
      // Configuration
      let preciseMode = true;
      let performanceMode = 'eco'; // 'eco' or 'rich'
      let useGaussian = true;
      let useHullPatches = true;
      let useDirectional = true;
      let sameColorMode = true;
      
      let SLIP_THRESHOLD = 0.05;
      let WEAR_INTENSITY = 0.7;
      let HULL_SENSITIVITY = 0.8;
      let SAMPLE_RATE = 120;
      let globalPaintColor = 0x00ff88;
      
      document.getElementById('loading').style.display = 'none';
      document.getElementById('ui-left').style.display = 'flex';
      document.getElementById('ui-right').style.display = 'flex';
      document.getElementById('info').style.display = 'block';
      document.getElementById('stats').style.display = 'block';

      // Physics setup
      const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
      const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
      const overlappingPairCache = new Ammo.btDbvtBroadphase();
      const solver = new Ammo.btSequentialImpulseConstraintSolver();
      const physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
      physicsWorld.setGravity(new Ammo.btVector3(0, -9.8, 0));

      // Three.js setup
      const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x16213e, 20, 80);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(15, 12, 15);
      camera.lookAt(0, 0, 0);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI * 0.49;
      controls.minDistance = 5;
      controls.maxDistance = 50;

      // Lighting
      scene.add(new THREE.AmbientLight(0x404040, 0.8));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
      dirLight.position.set(10, 20, 10);
      dirLight.castShadow = true;
      dirLight.shadow.camera.near = 0.1;
      dirLight.shadow.camera.far = 60;
      dirLight.shadow.camera.left = -25;
      dirLight.shadow.camera.right = 25;
      dirLight.shadow.camera.top = 25;
      dirLight.shadow.camera.bottom = -25;
      dirLight.shadow.mapSize.set(2048, 2048);
      scene.add(dirLight);

      const pointLight1 = new THREE.PointLight(0x00ff88, 0.5, 40);
      pointLight1.position.set(-15, 15, -15);
      scene.add(pointLight1);

      let physicsParams = { restitution: 0.3, friction: 0.5 };
      const rigidBodies = [];
      const tmpTrans = new Ammo.btTransform();
      
      let totalWearPoints = 0;
      let totalHullPatches = 0;
      let physicsSteps = 0;

      // Ground setup
      const groundSize = 50;
      const groundGeo = new THREE.BoxGeometry(groundSize, 2, groundSize);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2e, roughness: 0.9, metalness: 0.0 });
      const groundMesh = new THREE.Mesh(groundGeo, groundMat);
      groundMesh.position.y = -1;
      groundMesh.receiveShadow = true;
      scene.add(groundMesh);

      const grid = new THREE.GridHelper(groundSize, 50, 0x00ff88, 0x003344);
      grid.position.y = 0.005;
      scene.add(grid);

      // Multiple paint layers for wear simulation
      const PAINT_RES = 2048;
      
      // Wear layer (continuous slip wear)
      const wearCanvas = document.createElement('canvas');
      wearCanvas.width = PAINT_RES;
      wearCanvas.height = PAINT_RES;
      const wearCtx = wearCanvas.getContext('2d', { willReadFrequently: false });
      wearCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);

      const wearTex = new THREE.CanvasTexture(wearCanvas);
      wearTex.flipY = true;
      wearTex.wrapS = wearTex.wrapT = THREE.ClampToEdgeWrapping;
      wearTex.needsUpdate = true;

      // Directional wear layer
      const directionalCanvas = document.createElement('canvas');
      directionalCanvas.width = PAINT_RES;
      directionalCanvas.height = PAINT_RES;
      const directionalCtx = directionalCanvas.getContext('2d', { willReadFrequently: false });
      directionalCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);

      const directionalTex = new THREE.CanvasTexture(directionalCanvas);
      directionalTex.flipY = true;
      directionalTex.wrapS = directionalTex.wrapT = THREE.ClampToEdgeWrapping;
      directionalTex.needsUpdate = true;

      // Composite wear visualization
      const wearMaterial = new THREE.ShaderMaterial({
        uniforms: {
          wearTexture: { value: wearTex },
          directionalTexture: { value: directionalTex },
          wearOpacity: { value: 1.0 },
          directionalOpacity: { value: 0.6 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D wearTexture;
          uniform sampler2D directionalTexture;
          uniform float wearOpacity;
          uniform float directionalOpacity;
          varying vec2 vUv;
          
          void main() {
            vec4 wear = texture2D(wearTexture, vUv);
            vec4 directional = texture2D(directionalTexture, vUv);
            
            // Composite layers with wear simulation
            vec4 color = vec4(0.0);
            color = mix(color, wear, wear.a * wearOpacity);
            color = mix(color, directional, directional.a * directionalOpacity);
            
            // Enhance wear appearance
            color.rgb *= 1.0 + wear.a * 0.5; // Brighten worn areas
            
            gl_FragColor = color;
          }
        `,
        transparent: true,
        depthWrite: false
      });

      const wearPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(groundSize, groundSize),
        wearMaterial
      );
      wearPlane.rotation.x = -Math.PI / 2;
      wearPlane.position.y = 0.011;
      scene.add(wearPlane);

      // Ground physics body
      const groundShape = new Ammo.btBoxShape(new Ammo.btVector3(groundSize / 2, 1, groundSize / 2));
      const groundTransform = new Ammo.btTransform();
      groundTransform.setIdentity();
      groundTransform.setOrigin(new Ammo.btVector3(0, -1, 0));
      const groundMotionState = new Ammo.btDefaultMotionState(groundTransform);
      const groundRbInfo = new Ammo.btRigidBodyConstructionInfo(0, groundMotionState, groundShape, new Ammo.btVector3(0, 0, 0));
      groundRbInfo.set_m_restitution(0.3);
      groundRbInfo.set_m_friction(0.5);
      const groundBody = new Ammo.btRigidBody(groundRbInfo);
      physicsWorld.addRigidBody(groundBody);
      groundMesh.userData.physicsBody = groundBody;

      // Contact tracking for interpolation
      const contactHistory = new Map();
      const manifoldBuckets = new Map();
      const MANIFOLD_WINDOW_MS = 90;

      // Smoothstep function
      function smoothstep(edge0, edge1, x) {
        const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
        return t * t * (3 - 2 * t);
      }

      // Gaussian falloff
      function gaussianFalloff(distance, sigma = 0.5) {
        return Math.exp(-0.5 * (distance * distance) / (sigma * sigma));
      }

      // Compute slip velocity and wear direction
      function computeSlipVelocity(body, contactPoint, normal) {
        const v = body.getLinearVelocity();
        const w = body.getAngularVelocity();
        body.getMotionState().getWorldTransform(tmpTrans);
        const pos = tmpTrans.getOrigin();
        
        const r = new THREE.Vector3(
          contactPoint.x - pos.x(),
          contactPoint.y - pos.y(),
          contactPoint.z - pos.z()
        );
        
        const contactVel = new THREE.Vector3(
          v.x() + w.y() * r.z - w.z() * r.y,
          v.y() + w.z() * r.x - w.x() * r.z,
          v.z() + w.x() * r.y - w.y() * r.x
        );
        
        const normalVel = normal.clone().multiplyScalar(contactVel.dot(normal));
        const slipVel = contactVel.clone().sub(normalVel);
        
        return { slipVel, speed: slipVel.length(), contactVel };
      }

      // Draw wear with directional reinforcement
      function drawDirectionalWear(worldPoint, slipVel, pressure, color) {
        const u = THREE.MathUtils.clamp((worldPoint.x + groundSize / 2) / groundSize, 0, 1);
        const v = THREE.MathUtils.clamp((worldPoint.z + groundSize / 2) / groundSize, 0, 1);
        const px = u * PAINT_RES;
        const py = v * PAINT_RES;
        
        const speed = slipVel.length();
        const baseRadius = 0.05 + speed * 0.02 + pressure * 0.001;
        const rpx = Math.max(2, (baseRadius / groundSize) * PAINT_RES);
        
        const c = new THREE.Color(sameColorMode ? globalPaintColor : color);
        const intensity = smoothstep(0, 1, speed * 10) * WEAR_INTENSITY;
        
        // Draw wear pattern
        wearCtx.save();
        wearCtx.globalCompositeOperation = 'lighter';
        
        if (performanceMode === 'rich') {
          wearCtx.filter = `blur(${rpx * 0.3}px)`;
        }
        
        if (useGaussian) {
          // Gaussian wear pattern
          const g = wearCtx.createRadialGradient(px, py, 0, px, py, rpx);
          const falloff0 = gaussianFalloff(0, 0.5);
          const falloff3 = gaussianFalloff(0.3, 0.5);
          const falloff6 = gaussianFalloff(0.6, 0.5);
          
          g.addColorStop(0, `rgba(${(c.r * 255) | 0},${(c.g * 255) | 0},${(c.b * 255) | 0},${intensity * falloff0})`);
          g.addColorStop(0.3, `rgba(${(c.r * 255) | 0},${(c.g * 255) | 0},${(c.b * 255) | 0},${intensity * falloff3})`);
          g.addColorStop(0.6, `rgba(${(c.r * 255) | 0},${(c.g * 255) | 0},${(c.b * 255) | 0},${intensity * falloff6})`);
          g.addColorStop(1, `rgba(${(c.r * 255) | 0},${(c.g * 255) | 0},${(c.b * 255) | 0},0)`);
          
          wearCtx.fillStyle = g;
        } else {
          // Linear falloff
          const g = wearCtx.createRadialGradient(px, py, 0, px, py, rpx);
          g.addColorStop(0, `rgba(${(c.r * 255) | 0},${(c.g * 255) | 0},${(c.b * 255) | 0},${intensity})`);
          g.addColorStop(0.5, `rgba(${(c.r * 255) | 0},${(c.g * 255) | 0},${(c.b * 255) | 0},${intensity * 0.5})`);
          g.addColorStop(1, `rgba(${(c.r * 255) | 0},${(c.g * 255) | 0},${(c.b * 255) | 0},0)`);
          
          wearCtx.fillStyle = g;
        }
        
        wearCtx.beginPath();
        wearCtx.arc(px, py, rpx, 0, Math.PI * 2);
        wearCtx.fill();
        wearCtx.restore();
        
        // Draw directional component
        if (useDirectional && speed > 0.01) {
          const dir = slipVel.clone().normalize();
          const streakLength = Math.min(30, speed * 15);
          const sx = px - dir.x * streakLength;
          const sy = py - dir.z * streakLength;
          
          directionalCtx.save();
          directionalCtx.globalCompositeOperation = 'screen';
          
          const gradient = directionalCtx.createLinearGradient(sx, sy, px, py);
          gradient.addColorStop(0, `rgba(${(c.r * 200) | 0},${(c.g * 200) | 0},${(c.b * 255) | 0},0)`);
          gradient.addColorStop(0.7, `rgba(${(c.r * 200) | 0},${(c.g * 200) | 0},${(c.b * 255) | 0},${intensity * 0.3})`);
          gradient.addColorStop(1, `rgba(${(c.r * 200) | 0},${(c.g * 200) | 0},${(c.b * 255) | 0},${intensity * 0.6})`);
          
          directionalCtx.strokeStyle = gradient;
          directionalCtx.lineWidth = rpx * 0.8;
          directionalCtx.lineCap = 'round';
          directionalCtx.beginPath();
          directionalCtx.moveTo(sx, sy);
          directionalCtx.lineTo(px, py);
          directionalCtx.stroke();
          
          directionalCtx.restore();
        }
        
        wearTex.needsUpdate = true;
        directionalTex.needsUpdate = true;
        totalWearPoints++;
      }

      // Convex hull for OBB patches
      function convexHull2D(pts) {
        if (pts.length <= 3) return pts.slice();
        const s = pts.slice().sort((a, b) => a.x === b.x ? a.y - b.y : a.x - b.x);
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
        const lower = [];
        for (const p of s) {
          while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) lower.pop();
          lower.push(p);
        }
        const upper = [];
        for (let i = s.length - 1; i >= 0; i--) {
          const p = s[i];
          while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) upper.pop();
          upper.push(p);
        }
        upper.pop();
        lower.pop();
        return lower.concat(upper);
      }

      // Minimum area rectangle for OBB
      function minAreaRect(h) {
        let best = { area: Infinity, cx: 0, cy: 0, ux: 1, uy: 0, vx: 0, vy: 1, ex: 0, ey: 0 };
        for (let k = 0; k < h.length; k++) {
          const a = h[k], b = h[(k + 1) % h.length];
          const ax = b.x - a.x, ay = b.y - a.y;
          const len = Math.hypot(ax, ay);
          if (len < 1e-7) continue;
          const ux = ax / len, uy = ay / len;
          const vx = -uy, vy = ux;
          let minU = Infinity, maxU = -Infinity, minV = Infinity, maxV = -Infinity;
          for (const p of h) {
            const u = p.x * ux + p.y * uy;
            const v = p.x * vx + p.y * vy;
            if (u < minU) minU = u;
            if (u > maxU) maxU = u;
            if (v < minV) minV = v;
            if (v > maxV) maxV = v;
          }
          const ex = (maxU - minU) / 2, ey = (maxV - minV) / 2;
          const area = (ex * 2) * (ey * 2);
          if (area < best.area) {
            const uc = (minU + maxU) / 2, vc = (minV + maxV) / 2;
            best = { area, cx: uc, cy: vc, ux, uy, vx, vy, ex, ey };
          }
        }
        return best;
      }

      // Draw OBB hull patch
      function drawOBBPatch(worldPoints, normal, color) {
        if (worldPoints.length < 3) return;
        
        // Project to 2D
        const n = normal.clone().normalize();
        const tmp = Math.abs(n.y) > 0.9 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(0, 1, 0);
        const t1 = new THREE.Vector3().crossVectors(tmp, n).normalize();
        const t2 = new THREE.Vector3().crossVectors(n, t1).normalize();
        
        const base = worldPoints[0];
        const pts2d = worldPoints.map(p => {
          const d = new THREE.Vector3().subVectors(p, base);
          return { x: d.dot(t1), y: d.dot(t2) };
        });
        
        const hull = convexHull2D(pts2d);
        if (hull.length < 3) return;
        
        const rect = minAreaRect(hull);
        
        // Transform back to world
        const center = new THREE.Vector3()
          .copy(base)
          .addScaledVector(t1, rect.cx)
          .addScaledVector(t2, rect.cy);
        
        const width = Math.max(0.05, rect.ex * 2);
        const height = Math.max(0.05, rect.ey * 2);
        
        // Draw the hull patch
        const u = THREE.MathUtils.clamp((center.x + groundSize / 2) / groundSize, 0, 1);
        const v = THREE.MathUtils.clamp((center.z + groundSize / 2) / groundSize, 0, 1);
        const px = u * PAINT_RES;
        const py = v * PAINT_RES;
        const rpx = Math.max(4, ((width + height) / 2 / groundSize) * PAINT_RES * HULL_SENSITIVITY);
        
        wearCtx.save();
        wearCtx.globalCompositeOperation = 'lighter';
        
        if (performanceMode === 'rich') {
          wearCtx.filter = `blur(${rpx * 0.2}px)`;
        }
        
        const c = new THREE.Color(sameColorMode ? globalPaintColor : color);
        const g = wearCtx.createRadialGradient(px, py, 0, px, py, rpx);
        g.addColorStop(0, `rgba(${(c.r * 200) | 0},${(c.g * 100) | 0},${(c.b * 100) | 0},0.6)`);
        g.addColorStop(0.5, `rgba(${(c.r * 200) | 0},${(c.g * 100) | 0},${(c.b * 100) | 0},0.3)`);
        g.addColorStop(1, `rgba(${(c.r * 200) | 0},${(c.g * 100) | 0},${(c.b * 100) | 0},0)`);
        
        wearCtx.fillStyle = g;
        wearCtx.beginPath();
        wearCtx.arc(px, py, rpx, 0, Math.PI * 2);
        wearCtx.fill();
        wearCtx.restore();
        
        wearTex.needsUpdate = true;
        totalHullPatches++;
      }

      // Process contacts with wear simulation
      function processContacts() {
        const numManifolds = dispatcher.getNumManifolds();
        const now = performance.now();
        
        for (let i = 0; i < numManifolds; i++) {
          const manifold = dispatcher.getManifoldByIndexInternal(i);
          const body0 = Ammo.castObject(manifold.getBody0(), Ammo.btRigidBody);
          const body1 = Ammo.castObject(manifold.getBody1(), Ammo.btRigidBody);
          const numContacts = manifold.getNumContacts();
          
          let mesh0 = null, mesh1 = null;
          for (const rb of rigidBodies) {
            if (rb.userData.physicsBody === body0) mesh0 = rb;
            if (rb.userData.physicsBody === body1) mesh1 = rb;
          }
          if (groundMesh.userData.physicsBody === body0) mesh0 = groundMesh;
          if (groundMesh.userData.physicsBody === body1) mesh1 = groundMesh;
          if (!mesh0 || !mesh1) continue;
          
          const manifoldKey = `${Ammo.getPointer(body0)}_${Ammo.getPointer(body1)}`;
          let bucket = manifoldBuckets.get(manifoldKey);
          if (!bucket) {
            bucket = { points: [], normal: new THREE.Vector3(), t0: now };
            manifoldBuckets.set(manifoldKey, bucket);
          }
          
          for (let j = 0; j < numContacts; j++) {
            const cp = manifold.getContactPoint(j);
            const distance = cp.getDistance();
            
            if (distance < 0.01) {
              const ptA = cp.getPositionWorldOnA();
              const ptB = cp.getPositionWorldOnB();
              const nB = cp.get_m_normalWorldOnB();
              const impulse = cp.getAppliedImpulse();
              
              const paintOn1 = (mesh0 !== groundMesh);
              const point = new THREE.Vector3(
                paintOn1 ? ptB.x() : ptA.x(),
                paintOn1 ? ptB.y() : ptA.y(),
                paintOn1 ? ptB.z() : ptA.z()
              );
              const normal = new THREE.Vector3(nB.x(), nB.y(), nB.z());
              const dynamicBody = paintOn1 ? body0 : body1;
              const dynamicMesh = paintOn1 ? mesh0 : mesh1;
              const surfaceMesh = paintOn1 ? mesh1 : mesh0;
              
              if (surfaceMesh !== groundMesh) continue;
              
              // Calculate slip and wear
              const { slipVel, speed } = computeSlipVelocity(dynamicBody, point, normal);
              
              // Apply wear if above threshold
              if (speed > SLIP_THRESHOLD) {
                drawDirectionalWear(point, slipVel, impulse, dynamicMesh.userData.color || globalPaintColor);
              }
              
              // Collect points for hull patches
              if (useHullPatches) {
                bucket.points.push(point.clone());
                bucket.normal.add(normal);
              }
            }
          }
          
          // Process hull patch if enough points
          if (useHullPatches && bucket.points.length >= 4 && (now - bucket.t0 > MANIFOLD_WINDOW_MS || bucket.points.length > 20)) {
            bucket.normal.normalize();
            drawOBBPatch(bucket.points, bucket.normal, globalPaintColor);
            manifoldBuckets.delete(manifoldKey);
          }
        }
        
        // Clean old buckets
        for (const [key, bucket] of manifoldBuckets) {
          if (now - bucket.t0 > MANIFOLD_WINDOW_MS * 2) {
            manifoldBuckets.delete(key);
          }
        }
      }

      // Create rigid body
      function createRigidBody(mesh, shape, mass, pos, quat) {
        const transform = new Ammo.btTransform();
        transform.setIdentity();
        transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
        transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
        const motionState = new Ammo.btDefaultMotionState(transform);
        const localInertia = new Ammo.btVector3(0, 0, 0);
        shape.calculateLocalInertia(mass, localInertia);
        const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
        rbInfo.set_m_restitution(physicsParams.restitution);
        rbInfo.set_m_friction(physicsParams.friction);
        const body = new Ammo.btRigidBody(rbInfo);
        body.setActivationState(4);
        mesh.userData.physicsBody = body;
        scene.add(mesh);
        physicsWorld.addRigidBody(body);
        rigidBodies.push(mesh);
        return body;
      }

      // Create shapes
      function createShape(type) {
        const pos = new THREE.Vector3((Math.random() - 0.5) * 10, 10 + Math.random() * 10, (Math.random() - 0.5) * 10);
        const quat = new THREE.Quaternion();
        const mass = 1 + Math.random() * 2;
        const color = sameColorMode ? globalPaintColor : (0x00ff88 + Math.floor(Math.random() * 0xffffff));
        let mesh, shape;

        if (type === 'sphere') {
          const r = 0.5 + Math.random() * 0.5;
          mesh = new THREE.Mesh(
            new THREE.SphereGeometry(r, 32, 16),
            new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.2 })
          );
          shape = new Ammo.btSphereShape(r);
        } else if (type === 'box') {
          const s = 0.5 + Math.random() * 0.5;
          mesh = new THREE.Mesh(
            new THREE.BoxGeometry(s * 2, s * 2, s * 2),
            new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.2 })
          );
          shape = new Ammo.btBoxShape(new Ammo.btVector3(s, s, s));
        } else if (type === 'cylinder') {
          const r = 0.5 + Math.random() * 0.3;
          const h = 1 + Math.random() * 0.5;
          mesh = new THREE.Mesh(
            new THREE.CylinderGeometry(r, r, h, 24),
            new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.2 })
          );
          shape = new Ammo.btCylinderShape(new Ammo.btVector3(r, h / 2, r));
        } else if (type === 'cone') {
          const r = 0.5 + Math.random() * 0.3;
          const h = 1 + Math.random() * 0.5;
          mesh = new THREE.Mesh(
            new THREE.ConeGeometry(r, h, 24),
            new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.2 })
          );
          shape = new Ammo.btConeShape(r, h);
        } else if (type === 'torus') {
          const g = new THREE.TorusGeometry(0.6, 0.25, 16, 28);
          mesh = new THREE.Mesh(g, new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.2 }));
          const hull = new Ammo.btConvexHullShape();
          const v = g.attributes.position.array;
          for (let i = 0; i < v.length; i += 3) {
            hull.addPoint(new Ammo.btVector3(v[i], v[i + 1], v[i + 2]), true);
          }
          shape = hull;
        } else if (type === 'compound') {
          const comp = new Ammo.btCompoundShape();
          const group = new THREE.Group();
          for (let i = 0; i < 3; i++) {
            const t = new Ammo.btTransform();
            t.setIdentity();
            const ox = (Math.random() - 0.5) * 1;
            const oy = (Math.random() - 0.5) * 1;
            const oz = (Math.random() - 0.5) * 1;
            t.setOrigin(new Ammo.btVector3(ox, oy, oz));
            const sub = new Ammo.btSphereShape(0.3);
            comp.addChildShape(t, sub);
            const m = new THREE.Mesh(
              new THREE.SphereGeometry(0.3),
              new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.2 })
            );
            m.position.set(ox, oy, oz);
            group.add(m);
          }
          mesh = group;
          shape = comp;
        } else return;

        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData.color = color;
        
        const body = createRigidBody(mesh, shape, mass, pos, quat);
        const lv = new Ammo.btVector3((Math.random() - 0.5) * 5, 0, (Math.random() - 0.5) * 5);
        body.setLinearVelocity(lv);
        const av = new Ammo.btVector3((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5);
        body.setAngularVelocity(av);
      }

      // Export functions
      function exportCanvas(canvas, filename) {
        canvas.toBlob(blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.click();
          URL.revokeObjectURL(url);
        });
      }

      function exportComposite() {
        const compositeCanvas = document.createElement('canvas');
        compositeCanvas.width = PAINT_RES;
        compositeCanvas.height = PAINT_RES;
        const ctx = compositeCanvas.getContext('2d');
        
        ctx.drawImage(wearCanvas, 0, 0);
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(directionalCanvas, 0, 0);
        
        exportCanvas(compositeCanvas, `wear_composite_${Date.now()}.png`);
      }

      function exportData() {
        const data = {
          timestamp: Date.now(),
          paintResolution: PAINT_RES,
          groundSize: groundSize,
          statistics: {
            wearPoints: totalWearPoints,
            hullPatches: totalHullPatches,
            bodies: rigidBodies.length
          },
          settings: {
            preciseMode,
            performanceMode,
            useGaussian,
            useHullPatches,
            useDirectional,
            slipThreshold: SLIP_THRESHOLD,
            wearIntensity: WEAR_INTENSITY,
            hullSensitivity: HULL_SENSITIVITY,
            sampleRate: SAMPLE_RATE
          }
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `wear_data_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      // UI Controls
      document.getElementById('dropSphere').addEventListener('click', () => createShape('sphere'));
      document.getElementById('dropBox').addEventListener('click', () => createShape('box'));
      document.getElementById('dropCylinder').addEventListener('click', () => createShape('cylinder'));
      document.getElementById('dropCone').addEventListener('click', () => createShape('cone'));
      document.getElementById('dropTorus').addEventListener('click', () => createShape('torus'));
      document.getElementById('dropCompound').addEventListener('click', () => createShape('compound'));

      document.getElementById('togglePrecise').addEventListener('click', (e) => {
        preciseMode = !preciseMode;
        e.target.classList.toggle('active', preciseMode);
        e.target.textContent = `Precise Mode: ${preciseMode ? 'ON' : 'OFF'}`;
      });

      document.getElementById('togglePerformance').addEventListener('click', (e) => {
        performanceMode = performanceMode === 'eco' ? 'rich' : 'eco';
        e.target.classList.toggle('active', performanceMode === 'eco');
        e.target.textContent = `Performance: ${performanceMode.toUpperCase()}`;
      });

      document.getElementById('toggleGaussian').addEventListener('click', (e) => {
        useGaussian = !useGaussian;
        e.target.classList.toggle('active', useGaussian);
        e.target.textContent = `Gaussian Falloff: ${useGaussian ? 'ON' : 'OFF'}`;
      });

      document.getElementById('toggleHullPatches').addEventListener('click', (e) => {
        useHullPatches = !useHullPatches;
        e.target.classList.toggle('active', useHullPatches);
        e.target.textContent = `Hull Patches: ${useHullPatches ? 'ON' : 'OFF'}`;
      });

      document.getElementById('toggleDirectional').addEventListener('click', (e) => {
        useDirectional = !useDirectional;
        e.target.classList.toggle('active', useDirectional);
        e.target.textContent = `Directional Wear: ${useDirectional ? 'ON' : 'OFF'}`;
      });

      document.getElementById('toggleSameColor').addEventListener('click', (e) => {
        sameColorMode = !sameColorMode;
        e.target.classList.toggle('active', sameColorMode);
        e.target.textContent = `Same Color Mode: ${sameColorMode ? 'ON' : 'OFF'}`;
      });

      document.getElementById('paintColor').addEventListener('input', (e) => {
        globalPaintColor = parseInt(e.target.value.replace('#', '0x'));
      });

      // Physics sliders
      const restitutionSlider = document.getElementById('restitutionSlider');
      const frictionSlider = document.getElementById('frictionSlider');
      const gravitySlider = document.getElementById('gravitySlider');
      
      restitutionSlider.addEventListener('input', () => {
        physicsParams.restitution = (+restitutionSlider.value) / 100;
        document.getElementById('restitutionValue').textContent = physicsParams.restitution.toFixed(2);
        for (const m of rigidBodies) {
          m.userData.physicsBody.setRestitution(physicsParams.restitution);
        }
        groundBody.setRestitution(physicsParams.restitution);
      });

      frictionSlider.addEventListener('input', () => {
        physicsParams.friction = (+frictionSlider.value) / 100;
        document.getElementById('frictionValue').textContent = physicsParams.friction.toFixed(2);
        for (const m of rigidBodies) {
          m.userData.physicsBody.setFriction(physicsParams.friction);
        }
        groundBody.setFriction(physicsParams.friction);
      });

      gravitySlider.addEventListener('input', () => {
        const g = (+gravitySlider.value) / 10;
        document.getElementById('gravityValue').textContent = g.toFixed(1);
        physicsWorld.setGravity(new Ammo.btVector3(0, -g, 0));
      });

      // Wear settings
      document.getElementById('slipThreshold').addEventListener('input', (e) => {
        SLIP_THRESHOLD = (+e.target.value) / 100;
        document.getElementById('slipThresholdValue').textContent = SLIP_THRESHOLD.toFixed(2);
      });

      document.getElementById('wearIntensity').addEventListener('input', (e) => {
        WEAR_INTENSITY = (+e.target.value) / 100;
        document.getElementById('wearIntensityValue').textContent = WEAR_INTENSITY.toFixed(1);
      });

      document.getElementById('hullSens').addEventListener('input', (e) => {
        HULL_SENSITIVITY = (+e.target.value) / 100;
        document.getElementById('hullSensValue').textContent = HULL_SENSITIVITY.toFixed(1);
      });

      document.getElementById('sampleRate').addEventListener('input', (e) => {
        SAMPLE_RATE = +e.target.value;
        document.getElementById('sampleRateValue').textContent = SAMPLE_RATE;
      });

      // Export buttons
      document.getElementById('exportWear').addEventListener('click', () => {
        exportCanvas(wearCanvas, `wear_map_${Date.now()}.png`);
      });

      document.getElementById('exportDirectional').addEventListener('click', () => {
        exportCanvas(directionalCanvas, `directional_wear_${Date.now()}.png`);
      });

      document.getElementById('exportComposite').addEventListener('click', exportComposite);
      document.getElementById('exportData').addEventListener('click', exportData);

      document.getElementById('clearPaint').addEventListener('click', () => {
        wearCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);
        wearTex.needsUpdate = true;
        directionalCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);
        directionalTex.needsUpdate = true;
        totalWearPoints = 0;
        totalHullPatches = 0;
        contactHistory.clear();
        manifoldBuckets.clear();
      });

      document.getElementById('reset').addEventListener('click', () => {
        for (let i = rigidBodies.length - 1; i >= 0; i--) {
          const m = rigidBodies[i];
          physicsWorld.removeRigidBody(m.userData.physicsBody);
          scene.remove(m);
          rigidBodies.pop();
        }
        wearCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);
        wearTex.needsUpdate = true;
        directionalCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);
        directionalTex.needsUpdate = true;
        totalWearPoints = 0;
        totalHullPatches = 0;
        contactHistory.clear();
        manifoldBuckets.clear();
      });

      // Mouse drag controls
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let dragging = false;
      let dragBody = null;
      let dragMesh = null;
      let dragLocal = null;
      let dragHeight = 0;
      let ctrlDown = false;
      const DRAG_STIFF = 200;
      const DRAG_DAMP = 20;

      function setControlsEnabled() {
        controls.enabled = !(ctrlDown || dragging);
      }

      function screenToWorldOnPlane(clientX, clientY, y) {
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -y);
        const pt = new THREE.Vector3();
        raycaster.ray.intersectPlane(plane, pt);
        return pt;
      }

      window.addEventListener('pointerdown', (e) => {
        if (!e.ctrlKey) return;
        e.preventDefault();
        
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        
        const intersects = raycaster.intersectObjects(rigidBodies, true);
        if (intersects.length) {
          let obj = intersects[0].object;
          while (obj && !obj.userData.physicsBody && obj.parent) obj = obj.parent;
          if (!obj || !obj.userData.physicsBody) return;
          
          dragMesh = obj;
          dragBody = obj.userData.physicsBody;
          dragging = true;
          setControlsEnabled();
          dragBody.activate();
          
          const hit = intersects[0].point.clone();
          dragLocal = hit.clone().applyMatrix4(new THREE.Matrix4().copy(obj.matrixWorld).invert());
          dragHeight = hit.y;
        }
      });

      window.addEventListener('pointermove', (e) => {
        if (!dragging || !dragBody) return;
        
        const worldGrab = dragLocal.clone().applyMatrix4(dragMesh.matrixWorld);
        const target = screenToWorldOnPlane(e.clientX, e.clientY, dragHeight);
        const err = target.sub(worldGrab);
        const force = err.multiplyScalar(DRAG_STIFF);
        
        const f = new Ammo.btVector3(force.x, force.y, force.z);
        dragBody.applyCentralForce(f);
        Ammo.destroy(f);
        
        const lv = dragBody.getLinearVelocity();
        const damp = new Ammo.btVector3(-DRAG_DAMP * lv.x(), -DRAG_DAMP * lv.y(), -DRAG_DAMP * lv.z());
        dragBody.applyCentralForce(damp);
        Ammo.destroy(damp);
      });

      window.addEventListener('pointerup', () => {
        dragging = false;
        dragBody = null;
        dragMesh = null;
        dragLocal = null;
        setControlsEnabled();
      });

      window.addEventListener('keydown', (e) => {
        if (e.key === 'Control') {
          ctrlDown = true;
          setControlsEnabled();
          e.preventDefault();
        }
        if (!dragging) return;
        if (e.key === 'q' || e.key === 'Q') dragHeight -= 0.2;
        if (e.key === 'e' || e.key === 'E') dragHeight += 0.2;
      });

      window.addEventListener('keyup', (e) => {
        if (e.key === 'Control') {
          ctrlDown = false;
          setControlsEnabled();
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Animation loop
      const clock = new THREE.Clock();
      let frameCount = 0;
      let lastFps = 0;

      function updatePhysics(dt) {
        const substeps = preciseMode ? Math.ceil(dt * SAMPLE_RATE / 60) : 1;
        const subdt = dt / substeps;
        
        for (let step = 0; step < substeps; step++) {
          physicsWorld.stepSimulation(subdt, 1, 1 / 240);
          processContacts();
          physicsSteps++;
        }
        
        for (let i = 0; i < rigidBodies.length; i++) {
          const mesh = rigidBodies[i];
          const body = mesh.userData.physicsBody;
          if (body && body.getMotionState) {
            body.getMotionState().getWorldTransform(tmpTrans);
            const pos = tmpTrans.getOrigin();
            const quat = tmpTrans.getRotation();
            mesh.position.set(pos.x(), pos.y(), pos.z());
            mesh.quaternion.set(quat.x(), quat.y(), quat.z(), quat.w());
            
            if (pos.y() < -20) {
              physicsWorld.removeRigidBody(body);
              scene.remove(mesh);
              rigidBodies.splice(i, 1);
              i--;
            }
          }
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(clock.getDelta(), 0.1);
        
        updatePhysics(dt);
        
        frameCount++;
        const now = Date.now();
        if (now - lastFps > 1000) {
          document.getElementById('fps').textContent = frameCount;
          document.getElementById('physicsHz').textContent = Math.round(physicsSteps);
          frameCount = 0;
          physicsSteps = 0;
          lastFps = now;
        }
        
        document.getElementById('bodyCount').textContent = rigidBodies.length;
        document.getElementById('wearCount').textContent = totalWearPoints;
        document.getElementById('hullCount').textContent = totalHullPatches;
        document.getElementById('contactCount').textContent = manifoldBuckets.size;
        
        controls.update();
        renderer.render(scene, camera);
      }

      // Initial spawn
      function initSpawn() {
        for (let i = 0; i < 3; i++) createShape('box');
        for (let i = 0; i < 2; i++) createShape('sphere');
      }
      
      initSpawn();
      animate();
    });
  </script>
</body>
</html>