<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced Hardness-Based Wear Simulation with Traction Analysis</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: linear-gradient(180deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; color: #fff; overflow: hidden; }
    #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; z-index: 1000; }
    
    /* UI Panels */
    #ui-left { position: fixed; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 12px; z-index: 100; max-width: 360px; }
    #ui-right { position: fixed; top: 20px; right: 20px; display: flex; flex-direction: column; gap: 12px; z-index: 100; max-width: 360px; }
    
    .ui-group { background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); border-radius: 12px; padding: 14px; border: 1px solid rgba(255,255,255,0.1); }
    .ui-title { font-size: 11px; font-weight: bold; margin-bottom: 10px; color: #00ff88; text-transform: uppercase; letter-spacing: 1.5px; }
    button { width: 100%; padding: 10px; border: 0; border-radius: 8px; background: linear-gradient(135deg, #00ff88 0%, #00ccff 100%); color: #000; cursor: pointer; font-weight: 600; transition: all 0.3s; margin-bottom: 6px; font-size: 13px; }
    button:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4); }
    button.secondary { background: rgba(255,255,255,0.1); color: #fff; }
    button.secondary:hover { background: rgba(255,255,255,0.2); }
    button.active { background: linear-gradient(135deg, #ff0055 0%, #ff9a00 100%); color: #fff; }
    button.export { background: linear-gradient(135deg, #9333ea 0%, #4f46e5 100%); color: #fff; }
    .slider-container { margin: 10px 0; }
    .slider-label { font-size: 11px; margin-bottom: 6px; display: flex; justify-content: space-between; color: #00ff88; }
    input[type="range"] { width: 100%; height: 6px; border-radius: 3px; background: rgba(0,255,136,0.2); outline: none; -webkit-appearance: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #00ff88; cursor: pointer; box-shadow: 0 0 10px rgba(0,255,136,0.5); }
    input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #00ff88; cursor: pointer; border: none; box-shadow: 0 0 10px rgba(0,255,136,0.5); }
    
    select { width: 100%; padding: 8px; border: 1px solid rgba(0,255,136,0.3); border-radius: 6px; background: rgba(0,0,0,0.8); color: #00ff88; font-size: 12px; margin-bottom: 8px; }
    
    #info { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.85); padding: 16px; border-radius: 12px; font-size: 12px; backdrop-filter: blur(10px); max-width: 450px; border: 1px solid rgba(0,255,136,0.2); }
    #stats { position: fixed; bottom: 20px; right: 20px; background: rgba(0,0,0,0.85); padding: 16px; border-radius: 12px; font-size: 12px; backdrop-filter: blur(10px); border: 1px solid rgba(0,255,136,0.2); min-width: 240px; }
    .stat-item { display: flex; justify-content: space-between; margin: 6px 0; }
    .stat-label { color: #00ff88; }
    .stat-value { font-weight: bold; color: #00ccff; }
    canvas { display: block; }
    
    .wear-legend {
      display: flex; gap: 8px; margin-top: 8px;
      font-size: 10px; align-items: center; flex-wrap: wrap;
    }
    .wear-dot {
      width: 12px; height: 12px; border-radius: 50%;
      display: inline-block;
    }
    
    .material-indicator {
      padding: 4px 8px;
      background: rgba(0,255,136,0.1);
      border-radius: 4px;
      margin-top: 8px;
      font-size: 11px;
    }
  </style>
</head>
<body>
  <div id="loading">Loading Physics Engine...</div>

  <!-- Left UI Panel -->
  <div id="ui-left" style="display:none;">
    <div class="ui-group">
      <div class="ui-title">üéØ Drop Objects</div>
      <button id="dropSphere">Sphere</button>
      <button id="dropBox">Box</button>
      <button id="dropCylinder">Cylinder</button>
      <button id="dropCone">Cone</button>
      <button id="dropTorus">Torus</button>
      <button id="dropCompound">Compound</button>
      
      <div class="slider-container">
        <div class="slider-label"><span>Object Hardness</span><span id="objHardnessValue">0.5</span></div>
        <input type="range" id="objHardness" min="0" max="100" value="50">
      </div>
    </div>

    <div class="ui-group">
      <div class="ui-title">‚öôÔ∏è Physics</div>
      <div class="slider-container"><div class="slider-label"><span>Restitution</span><span id="restitutionValue">0.3</span></div><input type="range" id="restitutionSlider" min="0" max="100" value="30"></div>
      <div class="slider-container"><div class="slider-label"><span>Friction</span><span id="frictionValue">0.5</span></div><input type="range" id="frictionSlider" min="0" max="100" value="50"></div>
      <div class="slider-container"><div class="slider-label"><span>Gravity</span><span id="gravityValue">9.8</span></div><input type="range" id="gravitySlider" min="0" max="300" value="98"></div>
      
      <div class="slider-container">
        <div class="slider-label"><span>Ground Hardness</span><span id="groundHardnessValue">0.3</span></div>
        <input type="range" id="groundHardness" min="0" max="100" value="30">
      </div>
    </div>

    <div class="ui-group">
      <div class="ui-title">üé® Paint Modes</div>
      <select id="falloffMode">
        <option value="gaussian">Gaussian Falloff</option>
        <option value="quad">Quadratic Falloff</option>
        <option value="radial">Radial Gradient</option>
      </select>
      
      <button id="toggleInterp" class="active">Interpolation: ON</button>
      <button id="toggleHull" class="active">Hull Patches: ON</button>
      <button id="togglePerf" class="active">Performance: ECO</button>
    </div>
  </div>

  <!-- Right UI Panel -->
  <div id="ui-right" style="display:none;">
    <div class="ui-group">
      <div class="ui-title">üñåÔ∏è Wear Simulation</div>
      
      <div class="wear-legend">
        <span>Wear Types:</span>
        <span class="wear-dot" style="background: #ff0055;" title="High wear (low velocity, high traction)"></span>
        <span>High Wear</span>
        <span class="wear-dot" style="background: #ffaa00;" title="Medium wear"></span>
        <span>Medium</span>
        <span class="wear-dot" style="background: #00ff88;" title="Low wear (high velocity, low traction)"></span>
        <span>Low Wear</span>
      </div>
      
      <div class="slider-container">
        <div class="slider-label"><span>Slip Threshold</span><span id="slipThresholdValue">0.05</span></div>
        <input type="range" id="slipThreshold" min="1" max="100" value="5">
      </div>
      
      <div class="slider-container">
        <div class="slider-label"><span>Gaussian Radius</span><span id="gaussianRadiusValue">1.0</span></div>
        <input type="range" id="gaussianRadius" min="10" max="300" value="100">
      </div>
      
      <div class="slider-container">
        <div class="slider-label"><span>Wear Intensity</span><span id="wearIntensityValue">0.8</span></div>
        <input type="range" id="wearIntensity" min="10" max="100" value="80">
      </div>
      
      <div class="slider-container">
        <div class="slider-label"><span>Contact Reduction</span><span id="contactReductionValue">1</span></div>
        <input type="range" id="contactReduction" min="1" max="10" value="1">
      </div>
      
      <div class="slider-container">
        <div class="slider-label"><span>Trail Steps</span><span id="trailStepsValue">5</span></div>
        <input type="range" id="trailSteps" min="1" max="20" value="5">
      </div>
      
      <div class="material-indicator" id="materialInfo">
        Hardness Difference: <span id="hardnessDiff">0.2</span>
      </div>
      
      <button id="clearPaint" class="secondary">Clear All Layers</button>
      <button id="reset" class="secondary">Reset Scene</button>
    </div>

    <div class="ui-group">
      <div class="ui-title">üíæ Export</div>
      <button id="exportWear" class="export">Export Wear Map</button>
      <button id="exportTraction" class="export">Export Traction Map</button>
      <button id="exportComposite" class="export">Export Composite</button>
      <button id="exportData" class="export">Export Scene Data</button>
    </div>
  </div>

  <div id="info" style="display:none;">
    ‚ö° <b>Hardness-Based Wear Simulation</b><br>
    ‚Ä¢ <b>Red zones:</b> High wear (low velocity + high traction)<br>
    ‚Ä¢ <b>Orange zones:</b> Medium wear (balanced conditions)<br>
    ‚Ä¢ <b>Green zones:</b> Low wear (high velocity + low traction)<br>
    ‚Ä¢ <b>Hardness effect:</b> Softer materials wear faster<br>
    ‚Ä¢ <b>Hull patches:</b> Face-to-face contact areas with OBB detection<br>
    ‚Ä¢ <b>Ctrl + Drag:</b> Grab objects (Q/E for height)
  </div>

  <div id="stats" style="display:none;">
    <div class="stat-item"><span class="stat-label">Bodies:</span><span class="stat-value" id="bodyCount">0</span></div>
    <div class="stat-item"><span class="stat-label">Contacts:</span><span class="stat-value" id="contactCount">0</span></div>
    <div class="stat-item"><span class="stat-label">Wear Points:</span><span class="stat-value" id="wearCount">0</span></div>
    <div class="stat-item"><span class="stat-label">Hull Patches:</span><span class="stat-value" id="hullCount">0</span></div>
    <div class="stat-item"><span class="stat-label">Traction Avg:</span><span class="stat-value" id="tractionAvg">0.0</span></div>
    <div class="stat-item"><span class="stat-label">FPS:</span><span class="stat-value" id="fps">60</span></div>
  </div>

  <script src="https://cdn.jsdelivr.net/gh/kripken/ammo.js@main/builds/ammo.js"></script>
  <script type="importmap">{ 
    "imports": { 
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js", 
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" 
    } 
  }</script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    Ammo().then(function(Ammo) {
      // Configuration
      let performanceMode = 'eco'; // 'eco' or 'rich'
      let falloffMode = 'gaussian'; // 'gaussian', 'quad', 'radial'
      let useInterpolation = true;
      let useHullPatches = true;
      
      // Material properties
      let objectHardness = 0.5; // 0 = very soft, 1 = very hard
      let groundHardness = 0.3; // Ground is softer by default
      
      // Wear parameters
      let SLIP_THRESHOLD = 0.05;
      let GAUSSIAN_RADIUS = 1.0;
      let WEAR_INTENSITY = 0.8;
      let CONTACT_REDUCTION = 1;
      let TRAIL_STEPS = 5;
      
      document.getElementById('loading').style.display = 'none';
      document.getElementById('ui-left').style.display = 'flex';
      document.getElementById('ui-right').style.display = 'flex';
      document.getElementById('info').style.display = 'block';
      document.getElementById('stats').style.display = 'block';

      // Physics setup
      const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
      const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
      const overlappingPairCache = new Ammo.btDbvtBroadphase();
      const solver = new Ammo.btSequentialImpulseConstraintSolver();
      const physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
      physicsWorld.setGravity(new Ammo.btVector3(0, -9.8, 0));

      // Three.js setup
      const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x16213e, 20, 80);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(15, 12, 15);
      camera.lookAt(0, 0, 0);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI * 0.49;
      controls.minDistance = 5;
      controls.maxDistance = 50;

      // Lighting
      scene.add(new THREE.AmbientLight(0x404040, 0.8));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
      dirLight.position.set(10, 20, 10);
      dirLight.castShadow = true;
      dirLight.shadow.camera.near = 0.1;
      dirLight.shadow.camera.far = 60;
      dirLight.shadow.camera.left = -25;
      dirLight.shadow.camera.right = 25;
      dirLight.shadow.camera.top = 25;
      dirLight.shadow.camera.bottom = -25;
      dirLight.shadow.mapSize.set(2048, 2048);
      scene.add(dirLight);

      const pointLight1 = new THREE.PointLight(0x00ff88, 0.5, 40);
      pointLight1.position.set(-15, 15, -15);
      scene.add(pointLight1);

      let physicsParams = { restitution: 0.3, friction: 0.5 };
      const rigidBodies = [];
      const tmpTrans = new Ammo.btTransform();
      
      let totalWearPoints = 0;
      let totalHullPatches = 0;
      let avgTraction = 0;
      let tractionSamples = 0;
      let contactCounter = 0;

      // Ground setup
      const groundSize = 50;
      const groundGeo = new THREE.BoxGeometry(groundSize, 2, groundSize);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2e, roughness: 0.9, metalness: 0.0 });
      const groundMesh = new THREE.Mesh(groundGeo, groundMat);
      groundMesh.position.y = -1;
      groundMesh.receiveShadow = true;
      groundMesh.userData.hardness = groundHardness;
      scene.add(groundMesh);

      const grid = new THREE.GridHelper(groundSize, 50, 0x00ff88, 0x003344);
      grid.position.y = 0.005;
      scene.add(grid);

      // Multiple paint layers
      const PAINT_RES = performanceMode === 'rich' ? 2048 : 1024;
      
      // Wear layer with traction-based coloring
      const wearCanvas = document.createElement('canvas');
      wearCanvas.width = PAINT_RES;
      wearCanvas.height = PAINT_RES;
      const wearCtx = wearCanvas.getContext('2d', { willReadFrequently: false });
      wearCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);

      const wearTex = new THREE.CanvasTexture(wearCanvas);
      wearTex.flipY = true;
      wearTex.wrapS = wearTex.wrapT = THREE.ClampToEdgeWrapping;
      wearTex.needsUpdate = true;

      // Traction map layer
      const tractionCanvas = document.createElement('canvas');
      tractionCanvas.width = PAINT_RES;
      tractionCanvas.height = PAINT_RES;
      const tractionCtx = tractionCanvas.getContext('2d', { willReadFrequently: false });
      tractionCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);

      const tractionTex = new THREE.CanvasTexture(tractionCanvas);
      tractionTex.flipY = true;
      tractionTex.wrapS = tractionTex.wrapT = THREE.ClampToEdgeWrapping;
      tractionTex.needsUpdate = true;

      // Composite visualization
      const wearMaterial = new THREE.ShaderMaterial({
        uniforms: {
          wearTexture: { value: wearTex },
          tractionTexture: { value: tractionTex },
          wearOpacity: { value: 1.0 },
          tractionOpacity: { value: 0.5 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D wearTexture;
          uniform sampler2D tractionTexture;
          uniform float wearOpacity;
          uniform float tractionOpacity;
          varying vec2 vUv;
          
          void main() {
            vec4 wear = texture2D(wearTexture, vUv);
            vec4 traction = texture2D(tractionTexture, vUv);
            
            // Composite with wear visualization
            vec4 color = vec4(0.0);
            color = mix(color, wear, wear.a * wearOpacity);
            color = mix(color, traction, traction.a * tractionOpacity);
            
            gl_FragColor = color;
          }
        `,
        transparent: true,
        depthWrite: false
      });

      const wearPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(groundSize, groundSize),
        wearMaterial
      );
      wearPlane.rotation.x = -Math.PI / 2;
      wearPlane.position.y = 0.011;
      scene.add(wearPlane);

      // Ground physics body
      const groundShape = new Ammo.btBoxShape(new Ammo.btVector3(groundSize / 2, 1, groundSize / 2));
      const groundTransform = new Ammo.btTransform();
      groundTransform.setIdentity();
      groundTransform.setOrigin(new Ammo.btVector3(0, -1, 0));
      const groundMotionState = new Ammo.btDefaultMotionState(groundTransform);
      const groundRbInfo = new Ammo.btRigidBodyConstructionInfo(0, groundMotionState, groundShape, new Ammo.btVector3(0, 0, 0));
      groundRbInfo.set_m_restitution(0.3);
      groundRbInfo.set_m_friction(0.5);
      const groundBody = new Ammo.btRigidBody(groundRbInfo);
      physicsWorld.addRigidBody(groundBody);
      groundMesh.userData.physicsBody = groundBody;

      // Trail history for interpolation
      const trailHistory = new Map();
      const manifoldBuckets = new Map();
      const MANIFOLD_WINDOW_MS = 90;

      // Smoothstep function
      function smoothstep(edge0, edge1, x) {
        const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
        return t * t * (3 - 2 * t);
      }

      // Falloff functions
      function applyFalloff(distance, maxDistance, mode) {
        const normalized = Math.min(1, distance / maxDistance);
        
        if (mode === 'gaussian') {
          const sigma = GAUSSIAN_RADIUS * 0.5;
          return Math.exp(-0.5 * (normalized * normalized) / (sigma * sigma));
        } else if (mode === 'quad') {
          return Math.max(0, 1 - normalized * normalized);
        } else { // radial
          return Math.max(0, 1 - normalized);
        }
      }

      // Calculate wear color based on velocity and traction
      function getWearColor(velocity, traction, hardnessDiff) {
        // Low velocity + high traction = high wear (red)
        // High velocity + low traction = low wear (green)
        // Medium conditions = medium wear (orange)
        
        const speed = velocity.length();
        const normalizedSpeed = Math.min(1, speed / 5); // Normalize to 0-1
        const normalizedTraction = Math.min(1, traction);
        
        // Wear factor: inverse of speed, direct with traction
        const wearFactor = (1 - normalizedSpeed * 0.7) * (normalizedTraction * 0.8 + 0.2);
        
        // Adjust for hardness difference
        const adjustedWear = wearFactor * (1 + hardnessDiff * 2);
        
        // Color interpolation
        let color;
        if (adjustedWear > 0.66) {
          // High wear - red
          color = new THREE.Color(0xff0055);
        } else if (adjustedWear > 0.33) {
          // Medium wear - orange
          color = new THREE.Color(0xffaa00);
        } else {
          // Low wear - green
          color = new THREE.Color(0x00ff88);
        }
        
        return { color, wearFactor: adjustedWear };
      }

      // Compute slip velocity and traction
      function computeSlipAndTraction(body, contactPoint, normal, impulse) {
        const v = body.getLinearVelocity();
        const w = body.getAngularVelocity();
        body.getMotionState().getWorldTransform(tmpTrans);
        const pos = tmpTrans.getOrigin();
        
        const r = new THREE.Vector3(
          contactPoint.x - pos.x(),
          contactPoint.y - pos.y(),
          contactPoint.z - pos.z()
        );
        
        const contactVel = new THREE.Vector3(
          v.x() + w.y() * r.z - w.z() * r.y,
          v.y() + w.z() * r.x - w.x() * r.z,
          v.z() + w.x() * r.y - w.y() * r.x
        );
        
        const normalVel = normal.clone().multiplyScalar(contactVel.dot(normal));
        const slipVel = contactVel.clone().sub(normalVel);
        
        // Calculate traction (grip force)
        const traction = Math.min(1, impulse * physicsParams.friction / (1 + slipVel.length()));
        
        return { slipVel, speed: slipVel.length(), traction };
      }

      // Draw wear with hardness-based intensity
      function drawWear(worldPoint, slipVel, traction, objHardness, groundHardness) {
        const u = THREE.MathUtils.clamp((worldPoint.x + groundSize / 2) / groundSize, 0, 1);
        const v = THREE.MathUtils.clamp((worldPoint.z + groundSize / 2) / groundSize, 0, 1);
        const px = u * PAINT_RES;
        const py = v * PAINT_RES;
        
        // Hardness difference affects wear intensity
        const hardnessDiff = Math.max(0, groundHardness - objHardness);
        
        // Get wear color based on conditions
        const { color, wearFactor } = getWearColor(slipVel, traction, hardnessDiff);
        
        const baseRadius = 0.05 + slipVel.length() * 0.02;
        const rpx = Math.max(2, (baseRadius / groundSize) * PAINT_RES * GAUSSIAN_RADIUS);
        
        const intensity = wearFactor * WEAR_INTENSITY;
        
        // Draw wear pattern
        wearCtx.save();
        wearCtx.globalCompositeOperation = 'lighter';
        
        if (performanceMode === 'rich') {
          wearCtx.filter = `blur(${rpx * 0.2}px)`;
        }
        
        // Apply selected falloff
        const g = wearCtx.createRadialGradient(px, py, 0, px, py, rpx);
        
        for (let i = 0; i <= 1; i += 0.2) {
          const falloff = applyFalloff(i, 1, falloffMode);
          const alpha = intensity * falloff;
          const stop = Math.min(1, i);
          g.addColorStop(stop, `rgba(${(color.r * 255) | 0},${(color.g * 255) | 0},${(color.b * 255) | 0},${alpha})`);
        }
        
        wearCtx.fillStyle = g;
        wearCtx.beginPath();
        wearCtx.arc(px, py, rpx, 0, Math.PI * 2);
        wearCtx.fill();
        wearCtx.restore();
        
        // Draw traction map
        tractionCtx.save();
        tractionCtx.globalCompositeOperation = 'screen';
        
        const tColor = new THREE.Color().setHSL(0.5 - traction * 0.5, 0.8, 0.5);
        const tg = tractionCtx.createRadialGradient(px, py, 0, px, py, rpx * 0.7);
        tg.addColorStop(0, `rgba(${(tColor.r * 255) | 0},${(tColor.g * 255) | 0},${(tColor.b * 255) | 0},${traction * 0.5})`);
        tg.addColorStop(1, `rgba(${(tColor.r * 255) | 0},${(tColor.g * 255) | 0},${(tColor.b * 255) | 0},0)`);
        
        tractionCtx.fillStyle = tg;
        tractionCtx.beginPath();
        tractionCtx.arc(px, py, rpx * 0.7, 0, Math.PI * 2);
        tractionCtx.fill();
        tractionCtx.restore();
        
        wearTex.needsUpdate = true;
        tractionTex.needsUpdate = true;
        totalWearPoints++;
        
        // Update traction average
        avgTraction = (avgTraction * tractionSamples + traction) / (tractionSamples + 1);
        tractionSamples++;
      }

      // Interpolate trail between points
      function interpolateTrail(lastPoint, currentPoint, lastVel, currentVel, traction, objHardness, groundHardness) {
        if (!useInterpolation || !lastPoint) {
          drawWear(currentPoint, currentVel, traction, objHardness, groundHardness);
          return;
        }
        
        const distance = lastPoint.distanceTo(currentPoint);
        const steps = Math.min(TRAIL_STEPS, Math.ceil(distance / 0.05));
        
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const interpPoint = lastPoint.clone().lerp(currentPoint, t);
          const interpVel = lastVel.clone().lerp(currentVel, t);
          
          drawWear(interpPoint, interpVel, traction, objHardness, groundHardness);
        }
      }

      // Convex hull algorithm (from provided file)
      function convexHull2D(pts) {
        if (pts.length <= 3) return pts.slice();
        const s = pts.slice().sort((a, b) => a.x === b.x ? a.y - b.y : a.x - b.x);
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
        const lower = [];
        for (const p of s) {
          while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) lower.pop();
          lower.push(p);
        }
        const upper = [];
        for (let i = s.length - 1; i >= 0; i--) {
          const p = s[i];
          while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) upper.pop();
          upper.push(p);
        }
        upper.pop();
        lower.pop();
        return lower.concat(upper);
      }

      // Minimum area rectangle for OBB
      function minAreaRect(h) {
        let best = { area: Infinity, cx: 0, cy: 0, ux: 1, uy: 0, vx: 0, vy: 1, ex: 0, ey: 0 };
        for (let k = 0; k < h.length; k++) {
          const a = h[k], b = h[(k + 1) % h.length];
          const ax = b.x - a.x, ay = b.y - a.y;
          const len = Math.hypot(ax, ay);
          if (len < 1e-7) continue;
          const ux = ax / len, uy = ay / len;
          const vx = -uy, vy = ux;
          let minU = Infinity, maxU = -Infinity, minV = Infinity, maxV = -Infinity;
          for (const p of h) {
            const u = p.x * ux + p.y * uy;
            const v = p.x * vx + p.y * vy;
            if (u < minU) minU = u;
            if (u > maxU) maxU = u;
            if (v < minV) minV = v;
            if (v > maxV) maxV = v;
          }
          const ex = (maxU - minU) / 2, ey = (maxV - minV) / 2;
          const area = (ex * 2) * (ey * 2);
          if (area < best.area) {
            const uc = (minU + maxU) / 2, vc = (minV + maxV) / 2;
            best = { area, cx: uc, cy: vc, ux, uy, vx, vy, ex, ey };
          }
        }
        return best;
      }

      // Draw OBB hull patch
      function drawOBBPatch(worldPoints, normal, avgTraction, objHardness, groundHardness) {
        if (!useHullPatches || worldPoints.length < 3) return;
        
        // Project to 2D
        const n = normal.clone().normalize();
        const tmp = Math.abs(n.y) > 0.9 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(0, 1, 0);
        const t1 = new THREE.Vector3().crossVectors(tmp, n).normalize();
        const t2 = new THREE.Vector3().crossVectors(n, t1).normalize();
        
        const base = worldPoints[0];
        const pts2d = worldPoints.map(p => {
          const d = new THREE.Vector3().subVectors(p, base);
          return { x: d.dot(t1), y: d.dot(t2) };
        });
        
        const hull = convexHull2D(pts2d);
        if (hull.length < 3) return;
        
        const rect = minAreaRect(hull);
        
        // Transform back to world
        const center = new THREE.Vector3()
          .copy(base)
          .addScaledVector(t1, rect.cx)
          .addScaledVector(t2, rect.cy);
        
        const width = Math.max(0.05, rect.ex * 2);
        const height = Math.max(0.05, rect.ey * 2);
        
        // Draw hull patch with wear coloring
        const hardnessDiff = Math.max(0, groundHardness - objHardness);
        const { color } = getWearColor(new THREE.Vector3(0, 0, 1), avgTraction, hardnessDiff);
        
        const u = THREE.MathUtils.clamp((center.x + groundSize / 2) / groundSize, 0, 1);
        const v = THREE.MathUtils.clamp((center.z + groundSize / 2) / groundSize, 0, 1);
        const px = u * PAINT_RES;
        const py = v * PAINT_RES;
        const rpx = Math.max(4, ((width + height) / 2 / groundSize) * PAINT_RES);
        
        wearCtx.save();
        wearCtx.globalCompositeOperation = 'screen';
        
        if (performanceMode === 'rich') {
          wearCtx.filter = `blur(${rpx * 0.15}px)`;
        }
        
        const g = wearCtx.createRadialGradient(px, py, 0, px, py, rpx);
        g.addColorStop(0, `rgba(${(color.r * 200) | 0},${(color.g * 150) | 0},${(color.b * 150) | 0},0.4)`);
        g.addColorStop(0.5, `rgba(${(color.r * 200) | 0},${(color.g * 150) | 0},${(color.b * 150) | 0},0.2)`);
        g.addColorStop(1, `rgba(${(color.r * 200) | 0},${(color.g * 150) | 0},${(color.b * 150) | 0},0)`);
        
        wearCtx.fillStyle = g;
        wearCtx.beginPath();
        wearCtx.arc(px, py, rpx, 0, Math.PI * 2);
        wearCtx.fill();
        wearCtx.restore();
        
        wearTex.needsUpdate = true;
        totalHullPatches++;
      }

      // Process contacts
      function processContacts() {
        const numManifolds = dispatcher.getNumManifolds();
        const now = performance.now();
        let activeContacts = 0;
        
        for (let i = 0; i < numManifolds; i++) {
          const manifold = dispatcher.getManifoldByIndexInternal(i);
          const body0 = Ammo.castObject(manifold.getBody0(), Ammo.btRigidBody);
          const body1 = Ammo.castObject(manifold.getBody1(), Ammo.btRigidBody);
          const numContacts = manifold.getNumContacts();
          
          let mesh0 = null, mesh1 = null;
          for (const rb of rigidBodies) {
            if (rb.userData.physicsBody === body0) mesh0 = rb;
            if (rb.userData.physicsBody === body1) mesh1 = rb;
          }
          if (groundMesh.userData.physicsBody === body0) mesh0 = groundMesh;
          if (groundMesh.userData.physicsBody === body1) mesh1 = groundMesh;
          if (!mesh0 || !mesh1) continue;
          
          const manifoldKey = `${Ammo.getPointer(body0)}_${Ammo.getPointer(body1)}`;
          let bucket = manifoldBuckets.get(manifoldKey);
          if (!bucket) {
            bucket = { points: [], normal: new THREE.Vector3(), t0: now, tractionSum: 0, count: 0 };
            manifoldBuckets.set(manifoldKey, bucket);
          }
          
          for (let j = 0; j < numContacts; j++) {
            // Contact reduction for performance
            contactCounter++;
            if (CONTACT_REDUCTION > 1 && contactCounter % CONTACT_REDUCTION !== 0) continue;
            
            const cp = manifold.getContactPoint(j);
            const distance = cp.getDistance();
            
            if (distance < 0.01) {
              const ptA = cp.getPositionWorldOnA();
              const ptB = cp.getPositionWorldOnB();
              const nB = cp.get_m_normalWorldOnB();
              const impulse = cp.getAppliedImpulse();
              
              const paintOn1 = (mesh0 !== groundMesh);
              const point = new THREE.Vector3(
                paintOn1 ? ptB.x() : ptA.x(),
                paintOn1 ? ptB.y() : ptA.y(),
                paintOn1 ? ptB.z() : ptA.z()
              );
              const normal = new THREE.Vector3(nB.x(), nB.y(), nB.z());
              const dynamicBody = paintOn1 ? body0 : body1;
              const dynamicMesh = paintOn1 ? mesh0 : mesh1;
              const surfaceMesh = paintOn1 ? mesh1 : mesh0;
              
              if (surfaceMesh !== groundMesh) continue;
              
              // Get material hardness
              const objHard = dynamicMesh.userData.hardness || objectHardness;
              const groundHard = surfaceMesh.userData.hardness || groundHardness;
              
              // Calculate slip and traction
              const { slipVel, speed, traction } = computeSlipAndTraction(dynamicBody, point, normal, impulse);
              
              // Trail interpolation
              if (speed > SLIP_THRESHOLD) {
                const bodyKey = Ammo.getPointer(dynamicBody);
                const trail = trailHistory.get(bodyKey) || { lastPoint: null, lastVel: null };
                
                interpolateTrail(trail.lastPoint, point, trail.lastVel || slipVel, slipVel, traction, objHard, groundHard);
                
                trailHistory.set(bodyKey, { lastPoint: point.clone(), lastVel: slipVel.clone() });
                activeContacts++;
              }
              
              // Collect for hull patches
              if (useHullPatches) {
                bucket.points.push(point.clone());
                bucket.normal.add(normal);
                bucket.tractionSum += traction;
                bucket.count++;
              }
            }
          }
          
          // Process hull patch
          if (useHullPatches && bucket.points.length >= 4 && (now - bucket.t0 > MANIFOLD_WINDOW_MS || bucket.points.length > 20)) {
            bucket.normal.normalize();
            const avgTract = bucket.tractionSum / bucket.count;
            const objHard = mesh0 !== groundMesh ? (mesh0.userData.hardness || objectHardness) : (mesh1.userData.hardness || objectHardness);
            drawOBBPatch(bucket.points, bucket.normal, avgTract, objHard, groundHardness);
            manifoldBuckets.delete(manifoldKey);
          }
        }
        
        // Clean old buckets
        for (const [key, bucket] of manifoldBuckets) {
          if (now - bucket.t0 > MANIFOLD_WINDOW_MS * 2) {
            manifoldBuckets.delete(key);
          }
        }
        
        return activeContacts;
      }

      // Create rigid body
      function createRigidBody(mesh, shape, mass, pos, quat) {
        const transform = new Ammo.btTransform();
        transform.setIdentity();
        transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
        transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
        const motionState = new Ammo.btDefaultMotionState(transform);
        const localInertia = new Ammo.btVector3(0, 0, 0);
        shape.calculateLocalInertia(mass, localInertia);
        const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
        rbInfo.set_m_restitution(physicsParams.restitution);
        rbInfo.set_m_friction(physicsParams.friction);
        const body = new Ammo.btRigidBody(rbInfo);
        body.setActivationState(4);
        mesh.userData.physicsBody = body;
        mesh.userData.hardness = objectHardness;
        scene.add(mesh);
        physicsWorld.addRigidBody(body);
        rigidBodies.push(mesh);
        return body;
      }

      // Create shapes
      function createShape(type) {
        const pos = new THREE.Vector3((Math.random() - 0.5) * 10, 10 + Math.random() * 10, (Math.random() - 0.5) * 10);
        const quat = new THREE.Quaternion();
        const mass = 1 + Math.random() * 2;
        // Color based on hardness
        const hardnessHue = objectHardness * 240; // 0 (red/soft) to 240 (blue/hard)
        const color = new THREE.Color().setHSL(hardnessHue / 360, 0.7, 0.5);
        let mesh, shape;

        if (type === 'sphere') {
          const r = 0.5 + Math.random() * 0.5;
          mesh = new THREE.Mesh(
            new THREE.SphereGeometry(r, 32, 16),
            new THREE.MeshStandardMaterial({ color: color.getHex(), roughness: 0.4, metalness: 0.2 })
          );
          shape = new Ammo.btSphereShape(r);
        } else if (type === 'box') {
          const s = 0.5 + Math.random() * 0.5;
          mesh = new THREE.Mesh(
            new THREE.BoxGeometry(s * 2, s * 2, s * 2),
            new THREE.MeshStandardMaterial({ color: color.getHex(), roughness: 0.4, metalness: 0.2 })
          );
          shape = new Ammo.btBoxShape(new Ammo.btVector3(s, s, s));
        } else if (type === 'cylinder') {
          const r = 0.5 + Math.random() * 0.3;
          const h = 1 + Math.random() * 0.5;
          mesh = new THREE.Mesh(
            new THREE.CylinderGeometry(r, r, h, 24),
            new THREE.MeshStandardMaterial({ color: color.getHex(), roughness: 0.4, metalness: 0.2 })
          );
          shape = new Ammo.btCylinderShape(new Ammo.btVector3(r, h / 2, r));
        } else if (type === 'cone') {
          const r = 0.5 + Math.random() * 0.3;
          const h = 1 + Math.random() * 0.5;
          mesh = new THREE.Mesh(
            new THREE.ConeGeometry(r, h, 24),
            new THREE.MeshStandardMaterial({ color: color.getHex(), roughness: 0.4, metalness: 0.2 })
          );
          shape = new Ammo.btConeShape(r, h);
        } else if (type === 'torus') {
          const g = new THREE.TorusGeometry(0.6, 0.25, 16, 28);
          mesh = new THREE.Mesh(g, new THREE.MeshStandardMaterial({ color: color.getHex(), roughness: 0.4, metalness: 0.2 }));
          const hull = new Ammo.btConvexHullShape();
          const v = g.attributes.position.array;
          for (let i = 0; i < v.length; i += 3) {
            hull.addPoint(new Ammo.btVector3(v[i], v[i + 1], v[i + 2]), true);
          }
          shape = hull;
        } else if (type === 'compound') {
          const comp = new Ammo.btCompoundShape();
          const group = new THREE.Group();
          for (let i = 0; i < 3; i++) {
            const t = new Ammo.btTransform();
            t.setIdentity();
            const ox = (Math.random() - 0.5) * 1;
            const oy = (Math.random() - 0.5) * 1;
            const oz = (Math.random() - 0.5) * 1;
            t.setOrigin(new Ammo.btVector3(ox, oy, oz));
            const sub = new Ammo.btSphereShape(0.3);
            comp.addChildShape(t, sub);
            const m = new THREE.Mesh(
              new THREE.SphereGeometry(0.3),
              new THREE.MeshStandardMaterial({ color: color.getHex(), roughness: 0.4, metalness: 0.2 })
            );
            m.position.set(ox, oy, oz);
            group.add(m);
          }
          mesh = group;
          shape = comp;
        } else return;

        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData.hardness = objectHardness;
        
        const body = createRigidBody(mesh, shape, mass, pos, quat);
        const lv = new Ammo.btVector3((Math.random() - 0.5) * 5, 0, (Math.random() - 0.5) * 5);
        body.setLinearVelocity(lv);
        const av = new Ammo.btVector3((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5);
        body.setAngularVelocity(av);
      }

      // Export functions
      function exportCanvas(canvas, filename) {
        canvas.toBlob(blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.click();
          URL.revokeObjectURL(url);
        });
      }

      function exportComposite() {
        const compositeCanvas = document.createElement('canvas');
        compositeCanvas.width = PAINT_RES;
        compositeCanvas.height = PAINT_RES;
        const ctx = compositeCanvas.getContext('2d');
        
        ctx.drawImage(wearCanvas, 0, 0);
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(tractionCanvas, 0, 0);
        
        exportCanvas(compositeCanvas, `wear_composite_${Date.now()}.png`);
      }

      function exportData() {
        const data = {
          timestamp: Date.now(),
          paintResolution: PAINT_RES,
          groundSize: groundSize,
          statistics: {
            wearPoints: totalWearPoints,
            hullPatches: totalHullPatches,
            avgTraction: avgTraction.toFixed(3),
            bodies: rigidBodies.length
          },
          settings: {
            performanceMode,
            falloffMode,
            useInterpolation,
            useHullPatches,
            objectHardness,
            groundHardness,
            slipThreshold: SLIP_THRESHOLD,
            gaussianRadius: GAUSSIAN_RADIUS,
            wearIntensity: WEAR_INTENSITY,
            contactReduction: CONTACT_REDUCTION,
            trailSteps: TRAIL_STEPS
          }
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `wear_data_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      // UI Controls
      document.getElementById('dropSphere').addEventListener('click', () => createShape('sphere'));
      document.getElementById('dropBox').addEventListener('click', () => createShape('box'));
      document.getElementById('dropCylinder').addEventListener('click', () => createShape('cylinder'));
      document.getElementById('dropCone').addEventListener('click', () => createShape('cone'));
      document.getElementById('dropTorus').addEventListener('click', () => createShape('torus'));
      document.getElementById('dropCompound').addEventListener('click', () => createShape('compound'));

      document.getElementById('falloffMode').addEventListener('change', (e) => {
        falloffMode = e.target.value;
      });

      document.getElementById('toggleInterp').addEventListener('click', (e) => {
        useInterpolation = !useInterpolation;
        e.target.classList.toggle('active', useInterpolation);
        e.target.textContent = `Interpolation: ${useInterpolation ? 'ON' : 'OFF'}`;
      });

      document.getElementById('toggleHull').addEventListener('click', (e) => {
        useHullPatches = !useHullPatches;
        e.target.classList.toggle('active', useHullPatches);
        e.target.textContent = `Hull Patches: ${useHullPatches ? 'ON' : 'OFF'}`;
      });

      document.getElementById('togglePerf').addEventListener('click', (e) => {
        performanceMode = performanceMode === 'eco' ? 'rich' : 'eco';
        e.target.classList.toggle('active', performanceMode === 'eco');
        e.target.textContent = `Performance: ${performanceMode.toUpperCase()}`;
      });

      // Material hardness sliders
      document.getElementById('objHardness').addEventListener('input', (e) => {
        objectHardness = (+e.target.value) / 100;
        document.getElementById('objHardnessValue').textContent = objectHardness.toFixed(2);
        
        // Update existing bodies
        for (const mesh of rigidBodies) {
          mesh.userData.hardness = objectHardness;
        }
        
        updateHardnessDiff();
      });

      document.getElementById('groundHardness').addEventListener('input', (e) => {
        groundHardness = (+e.target.value) / 100;
        document.getElementById('groundHardnessValue').textContent = groundHardness.toFixed(2);
        groundMesh.userData.hardness = groundHardness;
        
        updateHardnessDiff();
      });

      function updateHardnessDiff() {
        const diff = Math.abs(groundHardness - objectHardness);
        document.getElementById('hardnessDiff').textContent = diff.toFixed(2);
      }

      // Physics sliders
      const restitutionSlider = document.getElementById('restitutionSlider');
      const frictionSlider = document.getElementById('frictionSlider');
      const gravitySlider = document.getElementById('gravitySlider');
      
      restitutionSlider.addEventListener('input', () => {
        physicsParams.restitution = (+restitutionSlider.value) / 100;
        document.getElementById('restitutionValue').textContent = physicsParams.restitution.toFixed(2);
        for (const m of rigidBodies) {
          m.userData.physicsBody.setRestitution(physicsParams.restitution);
        }
        groundBody.setRestitution(physicsParams.restitution);
      });

      frictionSlider.addEventListener('input', () => {
        physicsParams.friction = (+frictionSlider.value) / 100;
        document.getElementById('frictionValue').textContent = physicsParams.friction.toFixed(2);
        for (const m of rigidBodies) {
          m.userData.physicsBody.setFriction(physicsParams.friction);
        }
        groundBody.setFriction(physicsParams.friction);
      });

      gravitySlider.addEventListener('input', () => {
        const g = (+gravitySlider.value) / 10;
        document.getElementById('gravityValue').textContent = g.toFixed(1);
        physicsWorld.setGravity(new Ammo.btVector3(0, -g, 0));
      });

      // Wear settings
      document.getElementById('slipThreshold').addEventListener('input', (e) => {
        SLIP_THRESHOLD = (+e.target.value) / 100;
        document.getElementById('slipThresholdValue').textContent = SLIP_THRESHOLD.toFixed(2);
      });

      document.getElementById('gaussianRadius').addEventListener('input', (e) => {
        GAUSSIAN_RADIUS = (+e.target.value) / 100;
        document.getElementById('gaussianRadiusValue').textContent = GAUSSIAN_RADIUS.toFixed(1);
      });

      document.getElementById('wearIntensity').addEventListener('input', (e) => {
        WEAR_INTENSITY = (+e.target.value) / 100;
        document.getElementById('wearIntensityValue').textContent = WEAR_INTENSITY.toFixed(1);
      });

      document.getElementById('contactReduction').addEventListener('input', (e) => {
        CONTACT_REDUCTION = +e.target.value;
        document.getElementById('contactReductionValue').textContent = CONTACT_REDUCTION;
      });

      document.getElementById('trailSteps').addEventListener('input', (e) => {
        TRAIL_STEPS = +e.target.value;
        document.getElementById('trailStepsValue').textContent = TRAIL_STEPS;
      });

      // Export buttons
      document.getElementById('exportWear').addEventListener('click', () => {
        exportCanvas(wearCanvas, `wear_map_${Date.now()}.png`);
      });

      document.getElementById('exportTraction').addEventListener('click', () => {
        exportCanvas(tractionCanvas, `traction_map_${Date.now()}.png`);
      });

      document.getElementById('exportComposite').addEventListener('click', exportComposite);
      document.getElementById('exportData').addEventListener('click', exportData);

      document.getElementById('clearPaint').addEventListener('click', () => {
        wearCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);
        wearTex.needsUpdate = true;
        tractionCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);
        tractionTex.needsUpdate = true;
        totalWearPoints = 0;
        totalHullPatches = 0;
        avgTraction = 0;
        tractionSamples = 0;
        trailHistory.clear();
        manifoldBuckets.clear();
      });

      document.getElementById('reset').addEventListener('click', () => {
        for (let i = rigidBodies.length - 1; i >= 0; i--) {
          const m = rigidBodies[i];
          physicsWorld.removeRigidBody(m.userData.physicsBody);
          scene.remove(m);
          rigidBodies.pop();
        }
        wearCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);
        wearTex.needsUpdate = true;
        tractionCtx.clearRect(0, 0, PAINT_RES, PAINT_RES);
        tractionTex.needsUpdate = true;
        totalWearPoints = 0;
        totalHullPatches = 0;
        avgTraction = 0;
        tractionSamples = 0;
        trailHistory.clear();
        manifoldBuckets.clear();
      });

      // Mouse drag controls
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let dragging = false;
      let dragBody = null;
      let dragMesh = null;
      let dragLocal = null;
      let dragHeight = 0;
      let ctrlDown = false;
      const DRAG_STIFF = 200;
      const DRAG_DAMP = 20;

      function setControlsEnabled() {
        controls.enabled = !(ctrlDown || dragging);
      }

      function screenToWorldOnPlane(clientX, clientY, y) {
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -y);
        const pt = new THREE.Vector3();
        raycaster.ray.intersectPlane(plane, pt);
        return pt;
      }

      window.addEventListener('pointerdown', (e) => {
        if (!e.ctrlKey) return;
        e.preventDefault();
        
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        
        const intersects = raycaster.intersectObjects(rigidBodies, true);
        if (intersects.length) {
          let obj = intersects[0].object;
          while (obj && !obj.userData.physicsBody && obj.parent) obj = obj.parent;
          if (!obj || !obj.userData.physicsBody) return;
          
          dragMesh = obj;
          dragBody = obj.userData.physicsBody;
          dragging = true;
          setControlsEnabled();
          dragBody.activate();
          
          const hit = intersects[0].point.clone();
          dragLocal = hit.clone().applyMatrix4(new THREE.Matrix4().copy(obj.matrixWorld).invert());
          dragHeight = hit.y;
        }
      });

      window.addEventListener('pointermove', (e) => {
        if (!dragging || !dragBody) return;
        
        const worldGrab = dragLocal.clone().applyMatrix4(dragMesh.matrixWorld);
        const target = screenToWorldOnPlane(e.clientX, e.clientY, dragHeight);
        const err = target.sub(worldGrab);
        const force = err.multiplyScalar(DRAG_STIFF);
        
        const f = new Ammo.btVector3(force.x, force.y, force.z);
        dragBody.applyCentralForce(f);
        Ammo.destroy(f);
        
        const lv = dragBody.getLinearVelocity();
        const damp = new Ammo.btVector3(-DRAG_DAMP * lv.x(), -DRAG_DAMP * lv.y(), -DRAG_DAMP * lv.z());
        dragBody.applyCentralForce(damp);
        Ammo.destroy(damp);
      });

      window.addEventListener('pointerup', () => {
        dragging = false;
        dragBody = null;
        dragMesh = null;
        dragLocal = null;
        setControlsEnabled();
      });

      window.addEventListener('keydown', (e) => {
        if (e.key === 'Control') {
          ctrlDown = true;
          setControlsEnabled();
          e.preventDefault();
        }
        if (!dragging) return;
        if (e.key === 'q' || e.key === 'Q') dragHeight -= 0.2;
        if (e.key === 'e' || e.key === 'E') dragHeight += 0.2;
      });

      window.addEventListener('keyup', (e) => {
        if (e.key === 'Control') {
          ctrlDown = false;
          setControlsEnabled();
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Animation loop
      const clock = new THREE.Clock();
      let frameCount = 0;
      let lastFps = 0;

      function updatePhysics(dt) {
        const substeps = performanceMode === 'rich' ? 2 : 1;
        const subdt = dt / substeps;
        
        for (let step = 0; step < substeps; step++) {
          physicsWorld.stepSimulation(subdt, 1, 1 / 240);
        }
        
        const activeContacts = processContacts();
        
        for (let i = 0; i < rigidBodies.length; i++) {
          const mesh = rigidBodies[i];
          const body = mesh.userData.physicsBody;
          if (body && body.getMotionState) {
            body.getMotionState().getWorldTransform(tmpTrans);
            const pos = tmpTrans.getOrigin();
            const quat = tmpTrans.getRotation();
            mesh.position.set(pos.x(), pos.y(), pos.z());
            mesh.quaternion.set(quat.x(), quat.y(), quat.z(), quat.w());
            
            if (pos.y() < -20) {
              physicsWorld.removeRigidBody(body);
              scene.remove(mesh);
              rigidBodies.splice(i, 1);
              i--;
            }
          }
        }
        
        return activeContacts;
      }

      function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(clock.getDelta(), 0.1);
        
        const activeContacts = updatePhysics(dt);
        
        frameCount++;
        const now = Date.now();
        if (now - lastFps > 1000) {
          document.getElementById('fps').textContent = frameCount;
          frameCount = 0;
          lastFps = now;
        }
        
        document.getElementById('bodyCount').textContent = rigidBodies.length;
        document.getElementById('wearCount').textContent = totalWearPoints;
        document.getElementById('hullCount').textContent = totalHullPatches;
        document.getElementById('contactCount').textContent = activeContacts;
        document.getElementById('tractionAvg').textContent = avgTraction.toFixed(2);
        
        controls.update();
        renderer.render(scene, camera);
      }

      // Initial spawn
      function initSpawn() {
        for (let i = 0; i < 3; i++) createShape('box');
        for (let i = 0; i < 2; i++) createShape('sphere');
      }
      
      initSpawn();
      animate();
    });
  </script>
</body>
</html>