<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Contact Paint Physics - Full Collision System</title>
  <style>
    :root { color-scheme: dark; }
    html, body { 
      height: 100%; 
      margin: 0; 
      background: linear-gradient(180deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; 
      color: #fff; 
      overflow: hidden;
    }
    
    #ui { 
      position: fixed; 
      top: 20px; 
      left: 20px; 
      display: flex; 
      flex-direction: column;
      gap: 12px; 
      z-index: 100; 
      max-width: 200px;
    }
    
    .ui-group {
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .ui-title {
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 8px;
      color: #a0a0ff;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    button { 
      width: 100%;
      padding: 10px; 
      border: 0; 
      border-radius: 8px; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white; 
      cursor: pointer; 
      font-weight: 600;
      transition: all 0.3s;
      margin-bottom: 6px;
    }
    
    button:hover { 
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    button.secondary {
      background: rgba(255,255,255,0.1);
    }
    
    button.secondary:hover {
      background: rgba(255,255,255,0.2);
    }
    
    button.active {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }
    
    .slider-container {
      margin: 10px 0;
    }
    
    .slider-label {
      font-size: 12px;
      margin-bottom: 5px;
      display: flex;
      justify-content: space-between;
    }
    
    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255,255,255,0.1);
      outline: none;
      -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      border: none;
    }
    
    #info { 
      position: fixed; 
      bottom: 20px; 
      left: 20px; 
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 12px;
      font-size: 13px;
      backdrop-filter: blur(10px);
      max-width: 350px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    #stats {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 12px;
      font-size: 13px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      min-width: 150px;
    }
    
    .stat-item {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
    }
    
    .stat-label {
      color: #a0a0ff;
    }
    
    .stat-value {
      font-weight: bold;
    }
    
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="ui-group">
      <div class="ui-title">Drop Objects</div>
      <button id="dropSphere">Drop Sphere</button>
      <button id="dropCube">Drop Cube</button>
      <button id="dropTorus">Drop Torus</button>
      <button id="dropDodeca">Drop Dodeca</button>
      <button id="dropCone">Drop Cone</button>
      <button id="dropRandom">Drop Random</button>
    </div>
    
    <div class="ui-group">
      <div class="ui-title">Physics Controls</div>
      <div class="slider-container">
        <div class="slider-label">
          <span>Bounce</span>
          <span id="bounceValue">0.3</span>
        </div>
        <input type="range" id="bounceSlider" min="0" max="100" value="30">
      </div>
      <div class="slider-container">
        <div class="slider-label">
          <span>Friction</span>
          <span id="frictionValue">0.7</span>
        </div>
        <input type="range" id="frictionSlider" min="0" max="100" value="70">
      </div>
      <div class="slider-container">
        <div class="slider-label">
          <span>Gravity</span>
          <span id="gravityValue">9.8</span>
        </div>
        <input type="range" id="gravitySlider" min="0" max="200" value="98">
      </div>
    </div>
    
    <div class="ui-group">
      <div class="ui-title">Actions</div>
      <button id="rain" class="secondary">Auto Drop</button>
      <button id="clearDecals" class="secondary">Clear Paint</button>
      <button id="clearObjects" class="secondary">Clear Objects</button>
      <button id="reset" class="secondary">Reset All</button>
    </div>
  </div>
  
  <div id="info">
    ðŸŽ¨ <b>Contact Area Paint Physics</b><br>
    â€¢ Objects paint the exact contact area when colliding<br>
    â€¢ Full object-to-object collision detection<br>
    â€¢ Adjustable bounce, friction, and gravity<br>
    â€¢ Click objects to add force â€¢ Drag to orbit camera
  </div>
  
  <div id="stats">
    <div class="stat-item">
      <span class="stat-label">Objects:</span>
      <span class="stat-value" id="objectCount">0</span>
    </div>
    <div class="stat-item">
      <span class="stat-label">Paint Marks:</span>
      <span class="stat-value" id="decalCount">0</span>
    </div>
    <div class="stat-item">
      <span class="stat-label">Collisions:</span>
      <span class="stat-value" id="collisionCount">0</span>
    </div>
    <div class="stat-item">
      <span class="stat-label">FPS:</span>
      <span class="stat-value" id="fps">60</span>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';

    // Scene setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x24243e, 15, 60);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(12, 10, 12);
    camera.lookAt(0, 0, 0);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI * 0.49;

    // Lighting
    scene.add(new THREE.AmbientLight(0x404040, 0.8));
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(8, 15, 8);
    dirLight.castShadow = true;
    dirLight.shadow.camera.near = 0.1;
    dirLight.shadow.camera.far = 50;
    dirLight.shadow.camera.left = -20;
    dirLight.shadow.camera.right = 20;
    dirLight.shadow.camera.top = 20;
    dirLight.shadow.camera.bottom = -20;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    scene.add(dirLight);

    const pointLight1 = new THREE.PointLight(0x667eea, 0.5, 30);
    pointLight1.position.set(-10, 10, -10);
    scene.add(pointLight1);

    const pointLight2 = new THREE.PointLight(0xf093fb, 0.5, 30);
    pointLight2.position.set(10, 10, 10);
    scene.add(pointLight2);

    // Large ground plane
    const groundSize = 40;
    const groundGeo = new THREE.BoxGeometry(groundSize, 2, groundSize);
    const groundMat = new THREE.MeshStandardMaterial({ 
      color: 0x2a2a3e,
      roughness: 0.9,
      metalness: 0.1
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.position.y = -1;
    ground.receiveShadow = true;
    ground.userData.isGround = true;
    scene.add(ground);

    // Grid
    const grid = new THREE.GridHelper(groundSize, 40, 0x4a5568, 0x2d3748);
    grid.position.y = 0.01;
    scene.add(grid);

    // Physics parameters
    let physicsParams = {
      bounce: 0.3,
      friction: 0.7,
      gravity: 9.8
    };

    // Object management
    const physicsObjects = [];
    const colors = [
      0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xfeca57, 0x48dbfb,
      0xff9ff3, 0x54a0ff, 0xfd79a8, 0xa29bfe, 0x6c5ce7,
      0xffeaa7, 0x74b9ff, 0xa29bfe, 0xff7979, 0xbadc58
    ];

    let totalCollisions = 0;

    class PhysicsObject {
      constructor(geometry, position) {
        this.color = colors[Math.floor(Math.random() * colors.length)];
        this.mesh = new THREE.Mesh(
          geometry,
          new THREE.MeshStandardMaterial({ 
            color: this.color,
            roughness: 0.4,
            metalness: 0.2
          })
        );
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;
        this.mesh.userData.physicsObject = this;
        
        this.pos = position.clone();
        this.vel = new THREE.Vector3(
          (Math.random() - 0.5) * 3,
          0,
          (Math.random() - 0.5) * 3
        );
        this.angularVel = new THREE.Vector3(
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2
        );
        
        this.mesh.position.copy(this.pos);
        scene.add(this.mesh);
        
        // Compute bounding sphere for collision
        this.mesh.geometry.computeBoundingSphere();
        this.radius = this.mesh.geometry.boundingSphere.radius;
        this.mass = this.radius * this.radius * this.radius;
        
        this.lastGroundContact = 0;
        this.contactPoints = [];
      }

      checkGroundCollision() {
        const groundY = 0;
        const bottom = this.pos.y - this.radius;
        
        if (bottom <= groundY) {
          // Prevent penetration
          this.pos.y = groundY + this.radius;
          
          // Only create decal if significant downward velocity
          if (this.vel.y < -0.5 && Date.now() - this.lastGroundContact > 100) {
            this.createGroundDecal();
            this.lastGroundContact = Date.now();
          }
          
          // Apply bounce and friction
          if (this.vel.y < 0) {
            this.vel.y = -this.vel.y * physicsParams.bounce;
            this.vel.x *= physicsParams.friction;
            this.vel.z *= physicsParams.friction;
            this.angularVel.multiplyScalar(0.9);
            totalCollisions++;
          }
          
          // Stop tiny bounces
          if (Math.abs(this.vel.y) < 0.1) {
            this.vel.y = 0;
            this.pos.y = groundY + this.radius;
          }
        }
      }

      checkObjectCollision(other) {
        const dist = this.pos.distanceTo(other.pos);
        const minDist = this.radius + other.radius;
        
        if (dist < minDist && dist > 0.001) {
          // Collision detected!
          const normal = new THREE.Vector3().subVectors(this.pos, other.pos).normalize();
          
          // Separate objects
          const overlap = minDist - dist;
          const separation = normal.clone().multiplyScalar(overlap * 0.5);
          this.pos.add(separation);
          other.pos.sub(separation);
          
          // Calculate relative velocity
          const relVel = new THREE.Vector3().subVectors(this.vel, other.vel);
          const velAlongNormal = relVel.dot(normal);
          
          // Only resolve if velocities are converging
          if (velAlongNormal < 0) {
            // Calculate impulse
            const restitution = physicsParams.bounce;
            const impulse = 2 * velAlongNormal / (1/this.mass + 1/other.mass);
            const impulseVector = normal.clone().multiplyScalar(impulse * restitution);
            
            // Apply impulse
            this.vel.sub(impulseVector.clone().multiplyScalar(1/this.mass));
            other.vel.add(impulseVector.clone().multiplyScalar(1/other.mass));
            
            // Add some angular velocity for visual effect
            this.angularVel.add(new THREE.Vector3(
              (Math.random() - 0.5) * 2,
              (Math.random() - 0.5) * 2,
              (Math.random() - 0.5) * 2
            ));
            
            // Create contact decal at collision point
            const contactPoint = this.pos.clone().add(other.pos).multiplyScalar(0.5);
            if (Math.random() > 0.3) { // Don't create decal for every collision
              this.createCollisionDecal(contactPoint, normal);
            }
            
            totalCollisions++;
          }
        }
      }

      createGroundDecal() {
        const material = new THREE.MeshBasicMaterial({
          map: this.createContactTexture(this.radius * 2),
          transparent: true,
          depthWrite: false,
          polygonOffset: true,
          polygonOffsetFactor: -4,
          blending: THREE.NormalBlending,
          opacity: 0.8
        });
        
        const position = new THREE.Vector3(this.pos.x, 0.01, this.pos.z);
        const normal = new THREE.Vector3(0, 1, 0);
        const orientation = new THREE.Euler(0, Math.random() * Math.PI * 2, 0);
        
        // Size based on object radius and impact velocity
        const impactSize = this.radius * 2 * (1 + Math.abs(this.vel.y) * 0.1);
        const size = new THREE.Vector3(impactSize, impactSize, 0.5);
        
        const decalGeometry = new DecalGeometry(ground, position, orientation, size);
        const decalMesh = new THREE.Mesh(decalGeometry, material);
        decalsGroup.add(decalMesh);
      }

      createCollisionDecal(position, normal) {
        const material = new THREE.MeshBasicMaterial({
          map: this.createSplatterTexture(),
          transparent: true,
          depthWrite: false,
          polygonOffset: true,
          polygonOffsetFactor: -4,
          blending: THREE.NormalBlending,
          opacity: 0.6
        });
        
        const quaternion = new THREE.Quaternion();
        const matrix = new THREE.Matrix4();
        const target = position.clone().add(normal);
        matrix.lookAt(position, target, new THREE.Vector3(0, 1, 0));
        quaternion.setFromRotationMatrix(matrix);
        
        const orientation = new THREE.Euler().setFromQuaternion(quaternion);
        const size = new THREE.Vector3(this.radius * 1.5, this.radius * 1.5, 0.5);
        
        const decalGeometry = new DecalGeometry(ground, position, orientation, size);
        const decalMesh = new THREE.Mesh(decalGeometry, material);
        decalsGroup.add(decalMesh);
      }

      createContactTexture(size) {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        const c = new THREE.Color(this.color);
        
        // Main contact area (solid center)
        const mainGradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 100);
        mainGradient.addColorStop(0, `rgba(${c.r*255}, ${c.g*255}, ${c.b*255}, 0.9)`);
        mainGradient.addColorStop(0.5, `rgba(${c.r*255}, ${c.g*255}, ${c.b*255}, 0.7)`);
        mainGradient.addColorStop(0.8, `rgba(${c.r*255}, ${c.g*255}, ${c.b*255}, 0.3)`);
        mainGradient.addColorStop(1, `rgba(${c.r*255}, ${c.g*255}, ${c.b*255}, 0)`);
        
        ctx.fillStyle = mainGradient;
        ctx.fillRect(0, 0, 256, 256);
        
        // Add contact ring
        ctx.strokeStyle = `rgba(${c.r*255}, ${c.g*255}, ${c.b*255}, 0.4)`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(128, 128, 90, 0, Math.PI * 2);
        ctx.stroke();
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
      }

      createSplatterTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        const c = new THREE.Color(this.color);
        
        // Splatter pattern for collisions
        for (let i = 0; i < 15; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = 30 + Math.random() * 80;
          const x = 128 + Math.cos(angle) * dist;
          const y = 128 + Math.sin(angle) * dist;
          const r = Math.random() * 12 + 3;
          
          const g = ctx.createRadialGradient(x, y, 0, x, y, r);
          g.addColorStop(0, `rgba(${c.r*255}, ${c.g*255}, ${c.b*255}, 0.8)`);
          g.addColorStop(1, `rgba(${c.r*255}, ${c.g*255}, ${c.b*255}, 0)`);
          
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
      }

      update(dt) {
        // Apply gravity
        this.vel.y -= physicsParams.gravity * dt;
        
        // Update position
        this.pos.add(this.vel.clone().multiplyScalar(dt));
        
        // Check ground collision
        this.checkGroundCollision();
        
        // Apply air resistance
        this.vel.multiplyScalar(0.999);
        this.angularVel.multiplyScalar(0.98);
        
        // Update mesh
        this.mesh.position.copy(this.pos);
        this.mesh.rotation.x += this.angularVel.x * dt;
        this.mesh.rotation.y += this.angularVel.y * dt;
        this.mesh.rotation.z += this.angularVel.z * dt;
      }

      applyForce(force) {
        this.vel.add(force.clone().divideScalar(this.mass));
      }

      dispose() {
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
      }
    }

    // Decal management
    const decalsGroup = new THREE.Group();
    scene.add(decalsGroup);

    // Create different shapes
    function createShape(type) {
      const x = (Math.random() - 0.5) * 8;
      const z = (Math.random() - 0.5) * 8;
      const y = 5 + Math.random() * 5;
      
      let geometry;
      switch(type) {
        case 'sphere':
          geometry = new THREE.SphereGeometry(0.5, 32, 16);
          break;
        case 'cube':
          geometry = new THREE.BoxGeometry(1, 1, 1);
          break;
        case 'torus':
          geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32);
          break;
        case 'dodeca':
          geometry = new THREE.DodecahedronGeometry(0.6);
          break;
        case 'cone':
          geometry = new THREE.ConeGeometry(0.5, 1, 16);
          break;
        default:
          geometry = new THREE.SphereGeometry(0.5, 32, 16);
      }
      
      physicsObjects.push(new PhysicsObject(geometry, new THREE.Vector3(x, y, z)));
    }

    // Raycasting for interaction
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onPointerDown(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(physicsObjects.map(o => o.mesh));
      
      if (hits.length > 0) {
        const obj = hits[0].object.userData.physicsObject;
        if (obj) {
          // Apply upward force to clicked object
          obj.applyForce(new THREE.Vector3(
            (Math.random() - 0.5) * 20,
            30,
            (Math.random() - 0.5) * 20
          ));
        }
      }
    }
    window.addEventListener('pointerdown', onPointerDown);

    // Animation loop
    const clock = new THREE.Clock();
    let autoDropEnabled = false;
    let dropTimer = 0;
    let frameCount = 0;
    let lastFpsUpdate = 0;

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);
      
      // Update physics objects
      for (let i = 0; i < physicsObjects.length; i++) {
        physicsObjects[i].update(dt);
        
        // Check collisions with other objects
        for (let j = i + 1; j < physicsObjects.length; j++) {
          physicsObjects[i].checkObjectCollision(physicsObjects[j]);
        }
        
        // Remove objects that fell too far
        if (physicsObjects[i].pos.y < -20) {
          physicsObjects[i].dispose();
          physicsObjects.splice(i, 1);
          i--;
        }
      }
      
      // Auto drop
      if (autoDropEnabled) {
        dropTimer += dt;
        if (dropTimer > 0.8) {
          dropTimer = 0;
          const types = ['sphere', 'cube', 'torus', 'dodeca', 'cone'];
          createShape(types[Math.floor(Math.random() * types.length)]);
        }
      }
      
      // Update FPS
      frameCount++;
      const now = Date.now();
      if (now - lastFpsUpdate > 1000) {
        document.getElementById('fps').textContent = frameCount;
        frameCount = 0;
        lastFpsUpdate = now;
      }
      
      controls.update();
      renderer.render(scene, camera);
      updateStats();
    }

    function updateStats() {
      document.getElementById('objectCount').textContent = physicsObjects.length;
      document.getElementById('decalCount').textContent = decalsGroup.children.length;
      document.getElementById('collisionCount').textContent = totalCollisions;
    }

    // UI Controls
    document.getElementById('dropSphere').addEventListener('click', () => createShape('sphere'));
    document.getElementById('dropCube').addEventListener('click', () => createShape('cube'));
    document.getElementById('dropTorus').addEventListener('click', () => createShape('torus'));
    document.getElementById('dropDodeca').addEventListener('click', () => createShape('dodeca'));
    document.getElementById('dropCone').addEventListener('click', () => createShape('cone'));
    document.getElementById('dropRandom').addEventListener('click', () => {
      const types = ['sphere', 'cube', 'torus', 'dodeca', 'cone'];
      createShape(types[Math.floor(Math.random() * types.length)]);
    });
    
    document.getElementById('rain').addEventListener('click', (e) => {
      autoDropEnabled = !autoDropEnabled;
      e.target.classList.toggle('active');
      e.target.textContent = autoDropEnabled ? 'Stop Auto' : 'Auto Drop';
    });
    
    // Physics sliders
    document.getElementById('bounceSlider').addEventListener('input', (e) => {
      physicsParams.bounce = e.target.value / 100;
      document.getElementById('bounceValue').textContent = physicsParams.bounce.toFixed(2);
    });
    
    document.getElementById('frictionSlider').addEventListener('input', (e) => {
      physicsParams.friction = e.target.value / 100;
      document.getElementById('frictionValue').textContent = physicsParams.friction.toFixed(2);
    });
    
    document.getElementById('gravitySlider').addEventListener('input', (e) => {
      physicsParams.gravity = e.target.value / 10;
      document.getElementById('gravityValue').textContent = physicsParams.gravity.toFixed(1);
    });
    
    document.getElementById('clearDecals').addEventListener('click', () => {
      while (decalsGroup.children.length > 0) {
        const decal = decalsGroup.children[0];
        decal.geometry.dispose();
        decal.material.dispose();
        if (decal.material.map) decal.material.map.dispose();
        decalsGroup.remove(decal);
      }
    });
    
    document.getElementById('clearObjects').addEventListener('click', () => {
      while (physicsObjects.length > 0) {
        physicsObjects[0].dispose();
        physicsObjects.shift();
      }
    });
    
    document.getElementById('reset').addEventListener('click', () => {
      // Clear everything
      while (physicsObjects.length > 0) {
        physicsObjects[0].dispose();
        physicsObjects.shift();
      }
      
      while (decalsGroup.children.length > 0) {
        const decal = decalsGroup.children[0];
        decal.geometry.dispose();
        decal.material.dispose();
        if (decal.material.map) decal.material.map.dispose();
        decalsGroup.remove(decal);
      }
      
      // Reset counters
      totalCollisions = 0;
      
      // Reset auto drop
      autoDropEnabled = false;
      document.getElementById('rain').classList.remove('active');
      document.getElementById('rain').textContent = 'Auto Drop';
      
      // Reset physics params
      physicsParams.bounce = 0.3;
      physicsParams.friction = 0.7;
      physicsParams.gravity = 9.8;
      document.getElementById('bounceSlider').value = 30;
      document.getElementById('frictionSlider').value = 70;
      document.getElementById('gravitySlider').value = 98;
      document.getElementById('bounceValue').textContent = '0.3';
      document.getElementById('frictionValue').textContent = '0.7';
      document.getElementById('gravityValue').textContent = '9.8';
    });

    // Window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start animation
    animate();
    
    // Drop initial objects
    setTimeout(() => {
      createShape('sphere');
      setTimeout(() => createShape('cube'), 200);
      setTimeout(() => createShape('torus'), 400);
    }, 500);
  </script>
</body>
</html>